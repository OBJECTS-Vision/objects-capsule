"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@ramp-network";
exports.ids = ["vendor-chunks/@ramp-network"];
exports.modules = {

/***/ "(ssr)/./node_modules/@ramp-network/ramp-instant-sdk/dist/ramp-instant-sdk.es5.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@ramp-network/ramp-instant-sdk/dist/ramp-instant-sdk.es5.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RampInstantEventTypes: () => (/* binding */ WidgetEventTypes),\n/* harmony export */   RampInstantSDK: () => (/* binding */ RampInstantSDK)\n/* harmony export */ });\n/* Version: 4.0.5 - March 27, 2024 10:56:25 */\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nfunction __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n// Older browsers don't support event options, feature detect it.\n\n// Adopted and modified solution from Bohdan Didukh (2017)\n// https://stackoverflow.com/questions/41594997/ios-10-safari-prevent-scrolling-behind-a-fixed-overlay-and-maintain-scroll-posi\n\nvar hasPassiveEvents = false;\nif (typeof window !== 'undefined') {\n  var passiveTestOptions = {\n    get passive() {\n      hasPassiveEvents = true;\n      return undefined;\n    }\n  };\n  window.addEventListener('testPassive', null, passiveTestOptions);\n  window.removeEventListener('testPassive', null, passiveTestOptions);\n}\n\nvar isIosDevice = typeof window !== 'undefined' && window.navigator && window.navigator.platform && (/iP(ad|hone|od)/.test(window.navigator.platform) || window.navigator.platform === 'MacIntel' && window.navigator.maxTouchPoints > 1);\n\n\nvar locks = [];\nvar documentListenerAdded = false;\nvar initialClientY = -1;\nvar previousBodyOverflowSetting = void 0;\nvar previousBodyPaddingRight = void 0;\n\n// returns true if `el` should be allowed to receive touchmove events.\nvar allowTouchMove = function allowTouchMove(el) {\n  return locks.some(function (lock) {\n    if (lock.options.allowTouchMove && lock.options.allowTouchMove(el)) {\n      return true;\n    }\n\n    return false;\n  });\n};\n\nvar preventDefault = function preventDefault(rawEvent) {\n  var e = rawEvent || window.event;\n\n  // For the case whereby consumers adds a touchmove event listener to document.\n  // Recall that we do document.addEventListener('touchmove', preventDefault, { passive: false })\n  // in disableBodyScroll - so if we provide this opportunity to allowTouchMove, then\n  // the touchmove event on document will break.\n  if (allowTouchMove(e.target)) {\n    return true;\n  }\n\n  // Do not prevent if the event has more than one touch (usually meaning this is a multi touch gesture like pinch to zoom).\n  if (e.touches.length > 1) return true;\n\n  if (e.preventDefault) e.preventDefault();\n\n  return false;\n};\n\nvar setOverflowHidden = function setOverflowHidden(options) {\n  // If previousBodyPaddingRight is already set, don't set it again.\n  if (previousBodyPaddingRight === undefined) {\n    var _reserveScrollBarGap = !!options && options.reserveScrollBarGap === true;\n    var scrollBarGap = window.innerWidth - document.documentElement.clientWidth;\n\n    if (_reserveScrollBarGap && scrollBarGap > 0) {\n      previousBodyPaddingRight = document.body.style.paddingRight;\n      document.body.style.paddingRight = scrollBarGap + 'px';\n    }\n  }\n\n  // If previousBodyOverflowSetting is already set, don't set it again.\n  if (previousBodyOverflowSetting === undefined) {\n    previousBodyOverflowSetting = document.body.style.overflow;\n    document.body.style.overflow = 'hidden';\n  }\n};\n\nvar restoreOverflowSetting = function restoreOverflowSetting() {\n  if (previousBodyPaddingRight !== undefined) {\n    document.body.style.paddingRight = previousBodyPaddingRight;\n\n    // Restore previousBodyPaddingRight to undefined so setOverflowHidden knows it\n    // can be set again.\n    previousBodyPaddingRight = undefined;\n  }\n\n  if (previousBodyOverflowSetting !== undefined) {\n    document.body.style.overflow = previousBodyOverflowSetting;\n\n    // Restore previousBodyOverflowSetting to undefined\n    // so setOverflowHidden knows it can be set again.\n    previousBodyOverflowSetting = undefined;\n  }\n};\n\n// https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollHeight#Problems_and_solutions\nvar isTargetElementTotallyScrolled = function isTargetElementTotallyScrolled(targetElement) {\n  return targetElement ? targetElement.scrollHeight - targetElement.scrollTop <= targetElement.clientHeight : false;\n};\n\nvar handleScroll = function handleScroll(event, targetElement) {\n  var clientY = event.targetTouches[0].clientY - initialClientY;\n\n  if (allowTouchMove(event.target)) {\n    return false;\n  }\n\n  if (targetElement && targetElement.scrollTop === 0 && clientY > 0) {\n    // element is at the top of its scroll.\n    return preventDefault(event);\n  }\n\n  if (isTargetElementTotallyScrolled(targetElement) && clientY < 0) {\n    // element is at the bottom of its scroll.\n    return preventDefault(event);\n  }\n\n  event.stopPropagation();\n  return true;\n};\n\nvar disableBodyScroll = function disableBodyScroll(targetElement, options) {\n  // targetElement must be provided\n  if (!targetElement) {\n    // eslint-disable-next-line no-console\n    console.error('disableBodyScroll unsuccessful - targetElement must be provided when calling disableBodyScroll on IOS devices.');\n    return;\n  }\n\n  // disableBodyScroll must not have been called on this targetElement before\n  if (locks.some(function (lock) {\n    return lock.targetElement === targetElement;\n  })) {\n    return;\n  }\n\n  var lock = {\n    targetElement: targetElement,\n    options: options || {}\n  };\n\n  locks = [].concat(_toConsumableArray(locks), [lock]);\n\n  if (isIosDevice) {\n    targetElement.ontouchstart = function (event) {\n      if (event.targetTouches.length === 1) {\n        // detect single touch.\n        initialClientY = event.targetTouches[0].clientY;\n      }\n    };\n    targetElement.ontouchmove = function (event) {\n      if (event.targetTouches.length === 1) {\n        // detect single touch.\n        handleScroll(event, targetElement);\n      }\n    };\n\n    if (!documentListenerAdded) {\n      document.addEventListener('touchmove', preventDefault, hasPassiveEvents ? { passive: false } : undefined);\n      documentListenerAdded = true;\n    }\n  } else {\n    setOverflowHidden(options);\n  }\n};\n\nvar clearAllBodyScrollLocks = function clearAllBodyScrollLocks() {\n  if (isIosDevice) {\n    // Clear all locks ontouchstart/ontouchmove handlers, and the references.\n    locks.forEach(function (lock) {\n      lock.targetElement.ontouchstart = null;\n      lock.targetElement.ontouchmove = null;\n    });\n\n    if (documentListenerAdded) {\n      document.removeEventListener('touchmove', preventDefault, hasPassiveEvents ? { passive: false } : undefined);\n      documentListenerAdded = false;\n    }\n\n    // Reset initial clientY.\n    initialClientY = -1;\n  } else {\n    restoreOverflowSetting();\n  }\n\n  locks = [];\n};\n\nvar baseWidgetUrl = 'https://app.ramp.network/';\r\nvar SEND_CRYPTO_SUPPORTED_VERSION = 1;\r\n// It will be evaluated by rollup-plugin-version-injector\r\nvar SDK_VERSION = '4.0.5';\n\nvar PaymentMethodName;\r\n(function (PaymentMethodName) {\r\n    PaymentMethodName[\"MANUAL_BANK_TRANSFER\"] = \"MANUAL_BANK_TRANSFER\";\r\n    PaymentMethodName[\"AUTO_BANK_TRANSFER\"] = \"AUTO_BANK_TRANSFER\";\r\n    PaymentMethodName[\"CARD_PAYMENT\"] = \"CARD_PAYMENT\";\r\n    PaymentMethodName[\"APPLE_PAY\"] = \"APPLE_PAY\";\r\n})(PaymentMethodName || (PaymentMethodName = {}));\r\nvar PaymentMethodType;\r\n(function (PaymentMethodType) {\r\n    PaymentMethodType[\"SEPA\"] = \"SEPA\";\r\n    PaymentMethodType[\"CARD\"] = \"CARD\";\r\n    PaymentMethodType[\"APPLEPAY\"] = \"APPLEPAY\";\r\n    PaymentMethodType[\"GOOGLEPAY\"] = \"GOOGLEPAY\";\r\n    PaymentMethodType[\"PISP\"] = \"PISP\";\r\n    PaymentMethodType[\"SOFORT\"] = \"SOFORT\";\r\n    PaymentMethodType[\"PIX\"] = \"PIX\";\r\n})(PaymentMethodType || (PaymentMethodType = {}));\r\nvar PurchaseStatus;\r\n(function (PurchaseStatus) {\r\n    PurchaseStatus[\"INITIALIZED\"] = \"INITIALIZED\";\r\n    PurchaseStatus[\"PAYMENT_STARTED\"] = \"PAYMENT_STARTED\";\r\n    PurchaseStatus[\"PAYMENT_IN_PROGRESS\"] = \"PAYMENT_IN_PROGRESS\";\r\n    PurchaseStatus[\"PAYMENT_FAILED\"] = \"PAYMENT_FAILED\";\r\n    PurchaseStatus[\"PAYMENT_EXECUTED\"] = \"PAYMENT_EXECUTED\";\r\n    PurchaseStatus[\"FIAT_RECEIVED\"] = \"FIAT_RECEIVED\";\r\n    PurchaseStatus[\"FIAT_SENT\"] = \"FIAT_SENT\";\r\n    PurchaseStatus[\"EXPIRED\"] = \"EXPIRED\";\r\n    PurchaseStatus[\"CANCELLED\"] = \"CANCELLED\";\r\n    PurchaseStatus[\"RELEASING\"] = \"RELEASING\";\r\n    PurchaseStatus[\"RELEASED\"] = \"RELEASED\";\r\n})(PurchaseStatus || (PurchaseStatus = {}));\r\nvar EventSeverity;\r\n(function (EventSeverity) {\r\n    EventSeverity[\"VERBOSE\"] = \"VERBOSE\";\r\n    EventSeverity[\"DEBUG\"] = \"DEBUG\";\r\n    EventSeverity[\"INFO\"] = \"INFO\";\r\n    EventSeverity[\"WARNING\"] = \"WARNING\";\r\n    EventSeverity[\"ERROR\"] = \"ERROR\";\r\n    EventSeverity[\"CRITICAL\"] = \"CRITICAL\";\r\n})(EventSeverity || (EventSeverity = {}));\r\nvar WidgetEventTypes;\r\n(function (WidgetEventTypes) {\r\n    WidgetEventTypes[\"WIDGET_CLOSE\"] = \"WIDGET_CLOSE\";\r\n    WidgetEventTypes[\"WIDGET_CONFIG_DONE\"] = \"WIDGET_CONFIG_DONE\";\r\n    WidgetEventTypes[\"WIDGET_CONFIG_FAILED\"] = \"WIDGET_CONFIG_FAILED\";\r\n    WidgetEventTypes[\"PURCHASE_CREATED\"] = \"PURCHASE_CREATED\";\r\n    WidgetEventTypes[\"OFFRAMP_SALE_CREATED\"] = \"OFFRAMP_SALE_CREATED\";\r\n})(WidgetEventTypes || (WidgetEventTypes = {}));\r\nvar InternalEventTypes;\r\n(function (InternalEventTypes) {\r\n    InternalEventTypes[\"WIDGET_CLOSE_REQUEST\"] = \"WIDGET_CLOSE_REQUEST\";\r\n    InternalEventTypes[\"WIDGET_CLOSE_REQUEST_CANCELLED\"] = \"WIDGET_CLOSE_REQUEST_CANCELLED\";\r\n    InternalEventTypes[\"WIDGET_CLOSE_REQUEST_CONFIRMED\"] = \"WIDGET_CLOSE_REQUEST_CONFIRMED\";\r\n    InternalEventTypes[\"REQUEST_CRYPTO_ACCOUNT\"] = \"REQUEST_CRYPTO_ACCOUNT\";\r\n    InternalEventTypes[\"SEND_CRYPTO\"] = \"SEND_CRYPTO\";\r\n})(InternalEventTypes || (InternalEventTypes = {}));\r\nvar InternalSdkEventTypes;\r\n(function (InternalSdkEventTypes) {\r\n    InternalSdkEventTypes[\"REQUEST_CRYPTO_ACCOUNT_RESULT\"] = \"REQUEST_CRYPTO_ACCOUNT_RESULT\";\r\n    InternalSdkEventTypes[\"SEND_CRYPTO_RESULT\"] = \"SEND_CRYPTO_RESULT\";\r\n})(InternalSdkEventTypes || (InternalSdkEventTypes = {}));\n\nfunction getRandomIntString() {\r\n    try {\r\n        return String(crypto.getRandomValues(new Uint32Array(1))[0]);\r\n    }\r\n    catch (_a) {\r\n        // if `crypto` is not supported, fall back to Math.random\r\n        // tslint:disable-next-line:no-magic-numbers\r\n        return String(Math.floor(Math.random() * 10000000));\r\n    }\r\n}\r\nvar widgetDesktopWidth = 895;\r\nvar widgetDesktopHeight = 590;\r\nvar minWidgetMobileWidth = 320;\r\nvar minWidgetMobileHeight = 667;\r\nfunction normalizeConfigAndLogErrorsOnInvalidFields(config) {\r\n    var errors = [];\r\n    var configCopy = __assign({}, config);\r\n    if (![\r\n        'desktop',\r\n        'mobile',\r\n        'hosted-desktop',\r\n        'hosted-mobile',\r\n        'hosted-auto',\r\n        'auto',\r\n        'embedded-desktop',\r\n        'embedded-mobile',\r\n    ].includes(config.variant)) {\r\n        configCopy.variant = 'desktop';\r\n        errors.push({\r\n            fieldName: 'variant',\r\n            description: 'Invalid value for `variant` config field ',\r\n            exampleValue: \"'desktop'\",\r\n            severity: EventSeverity.WARNING,\r\n        });\r\n    }\r\n    if (config.variant === 'embedded-desktop' || config.variant === 'embedded-mobile') {\r\n        validateContainerNode(config.containerNode, config.variant);\r\n    }\r\n    if (!['embedded-desktop', 'embedded-mobile'].includes(configCopy.variant)) {\r\n        delete configCopy.containerNode;\r\n    }\r\n    if (typeof config.useSendCryptoCallback !== 'undefined') {\r\n        delete config.useSendCryptoCallback;\r\n    }\r\n    logErrors(errors);\r\n    return configCopy;\r\n}\r\nfunction logErrors(errors) {\r\n    if (!errors.length) {\r\n        return;\r\n    }\r\n    // tslint:disable:no-console\r\n    console.group('Config errors');\r\n    errors.forEach(function (error) {\r\n        console.group(error.fieldName);\r\n        console.log(error.description);\r\n        console.log(\"Example expected value: \".concat(error.exampleValue));\r\n        console.log(\"Severity: \".concat(error.severity));\r\n        console.groupEnd();\r\n    });\r\n    console.groupEnd();\r\n    // tslint:enable:no-console\r\n}\r\nfunction initEventListenersDict() {\r\n    var widgetEventTypes = Array.from(Object.values(WidgetEventTypes));\r\n    var internalEventTypes = Array.from(Object.values(InternalEventTypes));\r\n    return __spreadArray(__spreadArray([], widgetEventTypes, true), internalEventTypes, true).reduce(function (listenersDict, eventType) {\r\n        listenersDict[eventType] = [];\r\n        return listenersDict;\r\n    }, {});\r\n}\r\nfunction determineWidgetVariant(config) {\r\n    var _a;\r\n    var mediaQuery = '(min-width: 920px) and (min-height: 630px)';\r\n    var variant = (_a = config.variant) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase();\r\n    if (variant === 'mobile' ||\r\n        variant === 'desktop' ||\r\n        variant === 'hosted-mobile' ||\r\n        variant === 'hosted-desktop' ||\r\n        variant === 'embedded-desktop' ||\r\n        variant === 'embedded-mobile') {\r\n        return variant;\r\n    }\r\n    var isDesktop = window.matchMedia(mediaQuery).matches;\r\n    if (variant === 'hosted-auto') {\r\n        return isDesktop ? 'hosted-desktop' : 'hosted-mobile';\r\n    }\r\n    return isDesktop ? 'desktop' : 'mobile';\r\n}\r\nfunction isHtmlElement(element) {\r\n    return typeof element.blur === 'function';\r\n}\r\nfunction validateContainerNode(containerNode, variant) {\r\n    if (!document.body) {\r\n        throw new Error(\"Couldn't find <body> element.\");\r\n    }\r\n    if (!(containerNode instanceof HTMLElement)) {\r\n        throw new Error('Container node has to be a proper HTML element.');\r\n    }\r\n    if (!document.body.contains(containerNode)) {\r\n        throw new Error('Container node must be attached to the document.');\r\n    }\r\n    var _a = containerNode.getBoundingClientRect(), width = _a.width, height = _a.height;\r\n    if (variant === 'embedded-desktop') {\r\n        if (width + 1 < widgetDesktopWidth) {\r\n            throw new Error(\"Container node must be at least \".concat(widgetDesktopWidth, \"px wide.\"));\r\n        }\r\n        if (height + 1 < widgetDesktopHeight) {\r\n            throw new Error(\"Container node must be at least \".concat(widgetDesktopHeight, \"px tall.\"));\r\n        }\r\n    }\r\n    else if (variant === 'embedded-mobile') {\r\n        if (width + 1 < minWidgetMobileWidth) {\r\n            throw new Error(\"Container node must be at least \".concat(minWidgetMobileWidth, \"px wide.\"));\r\n        }\r\n        if (height + 1 < minWidgetMobileHeight) {\r\n            throw new Error(\"Container node must be at least \".concat(minWidgetMobileHeight, \"px tall.\"));\r\n        }\r\n    }\r\n}\n\nfunction getBaseUrl(config) {\r\n    return new URL(config.url || baseWidgetUrl);\r\n}\r\nfunction initWidgetIframeUrl(config) {\r\n    var baseUrl = getBaseUrl(config);\r\n    var hostUrl = window.location.origin;\r\n    config.containerNode; config.url; var configWithoutIframeUrl = __rest(config, [\"containerNode\", \"url\"]);\r\n    var preparedConfig = __assign(__assign({}, configWithoutIframeUrl), { hostUrl: hostUrl });\r\n    Object.entries(preparedConfig).forEach(function (_a) {\r\n        var key = _a[0], value = _a[1];\r\n        if (value) {\r\n            baseUrl.searchParams.append(key, Array.isArray(value) ? value.join(',') : value.toString());\r\n        }\r\n    });\r\n    return baseUrl.toString();\r\n}\r\nfunction hideWebsiteBelow(parent, containerWidth) {\r\n    var backgroundWebsiteHider = document.createElement('div');\r\n    backgroundWebsiteHider.classList.add('background-hider');\r\n    if (containerWidth) {\r\n        backgroundWebsiteHider.style.maxWidth = \"\".concat(containerWidth, \"px\");\r\n    }\r\n    parent.appendChild(backgroundWebsiteHider);\r\n}\r\nfunction initDOMNodeWithOverlay(url, dispatch, config) {\r\n    var body = document.querySelector('body');\r\n    var shadowHost = document.createElement('div');\r\n    shadowHost.style.width = '100%';\r\n    shadowHost.style.height = '100%';\r\n    var shadow = shadowHost.attachShadow({ mode: 'open' });\r\n    shadow.appendChild(getStylesForShadowDom(config.variant));\r\n    var iframe = prepareIframeNode(url, config.variant);\r\n    var overlay = prepareOverlayNode(iframe, dispatch);\r\n    overlay.appendChild(iframe);\r\n    shadow.appendChild(overlay);\r\n    return {\r\n        body: body,\r\n        iframe: iframe,\r\n        overlay: overlay,\r\n        shadow: shadow,\r\n        shadowHost: shadowHost,\r\n    };\r\n}\r\nfunction initDOMNodeWithoutOverlay(url, _dispatch, config) {\r\n    var body = document.querySelector('body');\r\n    var shadowHost = document.createElement('div');\r\n    shadowHost.style.width = '100%';\r\n    shadowHost.style.height = '100%';\r\n    var shadow = shadowHost.attachShadow({ mode: 'open' });\r\n    var container = document.createElement('div');\r\n    container.classList.add('embedded-container');\r\n    shadow.appendChild(container);\r\n    var loader = document.createElement('div');\r\n    loader.classList.add('loader-container');\r\n    // tslint:disable:max-line-length\r\n    loader.innerHTML = \"\\n    <svg width=\\\"92\\\" height=\\\"60\\\" viewBox=\\\"0 0 51 32\\\" fill=\\\"none\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" class=\\\"loader\\\">\\n      <path d=\\\"M16.2232 18.8309L22.282 24.912C22.7953 25.4272 22.7948 26.2647 22.281 26.7792L17.651 31.4158C16.8619 32.1947 15.5719 32.1947 14.7828 31.4158L0.591812 17.4093C-0.197271 16.6305 -0.197271 15.3571 0.591812 14.5783L14.7828 0.584122C15.5719 -0.194707 16.8619 -0.194707 17.651 0.584122L22.281 5.22078C22.7948 5.73535 22.7953 6.57281 22.282 7.08795L16.2232 13.1691C14.645 14.7267 14.645 17.2733 16.2232 18.8309Z\\\" fill=\\\"#21BF73\\\"></path>\\n      <path d=\\\"M34.4433 18.8309L28.3845 24.912C27.8712 25.4272 27.8717 26.2647 28.3855 26.7792L33.0155 31.4158C33.8046 32.1947 35.0946 32.1947 35.8837 31.4158L50.0747 17.4093C50.8638 16.6305 50.8638 15.3571 50.0747 14.5783L35.8837 0.584122C35.0946 -0.194707 33.8046 -0.194707 33.0155 0.584122L28.3855 5.22078C27.8717 5.73535 27.8712 6.57281 28.3845 7.08795L34.4433 13.1691C36.0215 14.7267 36.0215 17.2733 34.4433 18.8309Z\\\" fill=\\\"#0A6E5C\\\"></path>\\n      <path d=\\\"M17.8128 17.157C17.1737 16.518 17.1737 15.482 17.8128 14.843L24.1765 8.47926C24.8155 7.84025 25.8515 7.84025 26.4905 8.47926L32.8542 14.843C33.4932 15.482 33.4932 16.518 32.8542 17.157L26.4905 23.5207C25.8515 24.1598 24.8155 24.1598 24.1765 23.5207L17.8128 17.157Z\\\" fill=\\\"#21BF73\\\"></path>\\n    </svg>\";\r\n    // tslint:enable:max-line-length\r\n    container.appendChild(loader);\r\n    shadow.appendChild(getStylesForShadowDom(config.variant));\r\n    var iframe = prepareIframeNode(url, config.variant, config.containerNode);\r\n    container.appendChild(iframe);\r\n    return {\r\n        body: body,\r\n        iframe: iframe,\r\n        overlay: null,\r\n        shadow: shadow,\r\n        shadowHost: shadowHost,\r\n    };\r\n}\r\nfunction importFonts() {\r\n    if (document.querySelector('[data-ramp-font]')) {\r\n        return;\r\n    }\r\n    var font = document.createElement('link');\r\n    font.setAttribute('href', 'https://fonts.googleapis.com/css?family=Poppins:200,400,500,600,700&display=swap&subset=latin-ext');\r\n    font.setAttribute('rel', 'stylesheet');\r\n    font.setAttribute('data-ramp-font', '');\r\n    document.head.appendChild(font);\r\n}\r\nfunction prepareIframeNode(url, variant, containerNode) {\r\n    var iframe = document.createElement('iframe');\r\n    iframe.setAttribute('src', url);\r\n    if (containerNode) {\r\n        iframe.setAttribute('width', variant === 'desktop' || variant === 'embedded-desktop'\r\n            ? widgetDesktopWidth.toString()\r\n            : containerNode.getBoundingClientRect().width.toString());\r\n        iframe.setAttribute('height', variant === 'desktop' || variant === 'embedded-desktop'\r\n            ? widgetDesktopHeight.toString()\r\n            : containerNode.getBoundingClientRect().height.toString());\r\n    }\r\n    else {\r\n        iframe.setAttribute('width', variant === 'desktop' || variant === 'embedded-desktop'\r\n            ? widgetDesktopWidth.toString()\r\n            : window.innerWidth.toString());\r\n        iframe.setAttribute('height', variant === 'desktop' || variant === 'embedded-desktop'\r\n            ? widgetDesktopHeight.toString()\r\n            : window.innerHeight.toString());\r\n    }\r\n    iframe.setAttribute('allow', 'payment; microphone; camera; clipboard-read; clipboard-write');\r\n    iframe.classList.add('iframe');\r\n    return iframe;\r\n}\r\nfunction prepareOverlayNode(iframe, dispatch) {\r\n    var overlay = document.createElement('div');\r\n    overlay.classList.add('overlay');\r\n    var loader = document.createElement('div');\r\n    loader.classList.add('loader-container');\r\n    // tslint:disable:max-line-length\r\n    loader.innerHTML = \"\\n    <svg width=\\\"92\\\" height=\\\"60\\\" viewBox=\\\"0 0 51 32\\\" fill=\\\"none\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" class=\\\"loader\\\">\\n      <path d=\\\"M16.2232 18.8309L22.282 24.912C22.7953 25.4272 22.7948 26.2647 22.281 26.7792L17.651 31.4158C16.8619 32.1947 15.5719 32.1947 14.7828 31.4158L0.591812 17.4093C-0.197271 16.6305 -0.197271 15.3571 0.591812 14.5783L14.7828 0.584122C15.5719 -0.194707 16.8619 -0.194707 17.651 0.584122L22.281 5.22078C22.7948 5.73535 22.7953 6.57281 22.282 7.08795L16.2232 13.1691C14.645 14.7267 14.645 17.2733 16.2232 18.8309Z\\\" fill=\\\"#21BF73\\\"></path>\\n      <path d=\\\"M34.4433 18.8309L28.3845 24.912C27.8712 25.4272 27.8717 26.2647 28.3855 26.7792L33.0155 31.4158C33.8046 32.1947 35.0946 32.1947 35.8837 31.4158L50.0747 17.4093C50.8638 16.6305 50.8638 15.3571 50.0747 14.5783L35.8837 0.584122C35.0946 -0.194707 33.8046 -0.194707 33.0155 0.584122L28.3855 5.22078C27.8717 5.73535 27.8712 6.57281 28.3845 7.08795L34.4433 13.1691C36.0215 14.7267 36.0215 17.2733 34.4433 18.8309Z\\\" fill=\\\"#0A6E5C\\\"></path>\\n      <path d=\\\"M17.8128 17.157C17.1737 16.518 17.1737 15.482 17.8128 14.843L24.1765 8.47926C24.8155 7.84025 25.8515 7.84025 26.4905 8.47926L32.8542 14.843C33.4932 15.482 33.4932 16.518 32.8542 17.157L26.4905 23.5207C25.8515 24.1598 24.8155 24.1598 24.1765 23.5207L17.8128 17.157Z\\\" fill=\\\"#21BF73\\\"></path>\\n    </svg>\";\r\n    // tslint:enable:max-line-length\r\n    overlay.appendChild(loader);\r\n    overlay.addEventListener('click', function (event) {\r\n        if (event.target !== iframe && !overlay.querySelectorAll('.close-modal').length) {\r\n            dispatch({\r\n                type: InternalEventTypes.WIDGET_CLOSE_REQUEST,\r\n                payload: null,\r\n                internal: true,\r\n            });\r\n        }\r\n    });\r\n    return overlay;\r\n}\r\nfunction areUrlsEqual(url0, url1) {\r\n    return new URL(url0).toString() === new URL(url1).toString();\r\n}\r\nfunction isCloseModalAlreadyOpen(containerNode) {\r\n    return containerNode.querySelectorAll('.close-modal').length !== 0;\r\n}\r\nfunction prepareCloseModalNode(dispatch) {\r\n    var container = document.createElement('div');\r\n    container.classList.add('close-modal');\r\n    var textEl = document.createElement('div');\r\n    textEl.classList.add('close-modal__text');\r\n    textEl.textContent = 'Are you sure you want to exit Ramp and abandon the transaction?';\r\n    var buttonContainer = document.createElement('div');\r\n    buttonContainer.classList.add('close-modal__button-container');\r\n    var cancelButton = document.createElement('button');\r\n    cancelButton.setAttribute('type', 'button');\r\n    cancelButton.classList.add('close-modal__button');\r\n    cancelButton.classList.add('close-modal__button--cancel');\r\n    cancelButton.textContent = 'Cancel';\r\n    cancelButton.addEventListener('click', function (event) {\r\n        event.stopPropagation();\r\n        dispatch({\r\n            type: InternalEventTypes.WIDGET_CLOSE_REQUEST_CANCELLED,\r\n            payload: null,\r\n            internal: true,\r\n        });\r\n    });\r\n    var exitButton = document.createElement('button');\r\n    exitButton.setAttribute('type', 'button');\r\n    exitButton.classList.add('close-modal__button');\r\n    exitButton.classList.add('close-modal__button--exit');\r\n    exitButton.textContent = 'Exit';\r\n    exitButton.addEventListener('click', function (event) {\r\n        event.stopPropagation();\r\n        dispatch({\r\n            type: InternalEventTypes.WIDGET_CLOSE_REQUEST_CONFIRMED,\r\n            payload: null,\r\n            internal: true,\r\n        });\r\n    });\r\n    buttonContainer.appendChild(cancelButton);\r\n    buttonContainer.appendChild(exitButton);\r\n    container.appendChild(textEl);\r\n    container.appendChild(buttonContainer);\r\n    return container;\r\n}\r\nfunction getStylesForShadowDom(variant) {\r\n    var styles = document.createElement('style');\r\n    var isMobile = variant === 'mobile' ||\r\n        variant === 'hosted-mobile' ||\r\n        variant === 'embedded-mobile' ||\r\n        variant === 'webview-mobile';\r\n    var isEmbedded = variant === 'embedded-mobile' || variant === 'embedded-desktop';\r\n    styles.textContent = \"\\n\\n    .background-hider {\\n      content: '';\\n      height: 30vh;\\n      width: 100vw;\\n      position: fixed;\\n      bottom: 0;\\n      transform: translateY(50%);\\n      background-color: #f5f8fb;\\n      z-index: 999;\\n    }\\n\\n    .overlay {\\n      position: fixed;\\n      z-index: 1000;\\n      width: 100vw;\\n      height: \".concat(isMobile ? '100%;' : '100vh;', \"\\n      top: 0;\\n      left: 0;\\n      overflow: hidden;\\n      background-color: rgba(166, 174, 185, 0.7);\\n      display: flex;\\n      flex-flow: row nowrap;\\n      justify-content: center;\\n      \").concat(isMobile ? 'align-items: flex-start;' : 'align-items: center;', \"\\n    }\\n\\n    .embedded-container {\\n      z-index: 1000;\\n      position: relative;\\n      width: 100%;\\n      height: 100%;\\n      display: flex;\\n      flex-flow: row nowrap;\\n      justify-content: center;\\n      \").concat(isMobile ? 'align-items: flex-start;' : 'align-items: center;', \"\\n      min-width: \").concat(isMobile ? minWidgetMobileWidth : widgetDesktopWidth, \"px;\\n      min-height: \").concat(isMobile ? minWidgetMobileHeight : widgetDesktopHeight, \"px;\\n    }\\n\\n    .loader-container {\\n      align-self: center;\\n    }\\n\\n    .loader {\\n      transform-origin: center;\\n      animation: logoAnimation 4s linear infinite;\\n      width: 100px;\\n      height: auto;\\n      align-self: center;\\n    }\\n\\n    .loader path:nth-child(3) {\\n      transform-origin: center;\\n      position: relative;\\n    }\\n\\n    .loader path:nth-child(1) {\\n      transform-origin: center;\\n      position: relative;\\n      animation: box1Animation 4s linear infinite;\\n      transform: scale(0.4) translateX(6px);\\n    }\\n\\n    .loader path:nth-child(2) {\\n      transform-origin: center;\\n      position: relative;\\n      animation: box4Animation 4s linear infinite;\\n      transform: scale(0.4) translateX(-6px);\\n    }\\n\\n    @keyframes logoAnimation {\\n      10% {\\n        transform: rotate(180deg);\\n      }\\n      30%{\\n        transform: rotate(360deg);\\n      }\\n      70% {\\n        transform: rotate(360deg);\\n      }\\n      90% {\\n        transform: rotate(520deg);\\n      }\\n      100% {\\n        transform: rotate(720deg);\\n      }\\n    }\\n\\n    @keyframes box1Animation {\\n      0%, 10% {\\n        transform: scale(0.4) translateX(6px);\\n      }\\n      30%, 70% {\\n        transform: scale(1) translateX(0);\\n      }\\n      90% {\\n        transform: scale(0.4) translateX(6px);\\n      }\\n    }\\n\\n\\n    @keyframes box4Animation {\\n      0%, 10% {\\n        transform: scale(0.4) translateX(-6px);\\n      }\\n      30%, 70% {\\n        transform: scale(1) translateX(0);\\n      }\\n      90% {\\n        transform: scale(0.4) translateX(-6px);\\n      }\\n    }\\n\\n    .iframe {\\n      border: none;\\n      user-select: none;\\n      visibility: hidden;\\n      position: absolute;\\n      color-scheme: only light;\\n    }\\n\\n    .iframe.visible {\\n      visibility: visible;\\n      \").concat(!isEmbedded && isMobile\r\n        ? \"\\n        width: 100vw;\\n        height: 100%;\\n      \"\r\n        : '', \"\\n    }\\n\\n    .close-modal {\\n      font-family: 'Poppins', sans-serif;\\n      width: 678px;\\n      height: 276px;\\n      position: absolute;\\n      left: 50%;\\n      top: 50%;\\n      transform: translate(-50%, -50%);\\n      z-index: 9999;\\n      box-shadow: 0px 54px 200px rgba(36, 37, 57, 0.2);\\n      display: flex;\\n      flex-flow: column nowrap;\\n      justify-content: flex-start;\\n      align-items: center;\\n      padding: 35px;\\n      border-radius: 8px;\\n      background: #fff;\\n\\n      box-sizing: border-box;\\n    }\\n\\n    .close-modal * {\\n      box-sizing: border-box;\\n    }\\n\\n    .close-modal__text {\\n      margin: 40px auto 30px;\\n      font-weight: 600;\\n      font-size: 24px;\\n      line-height: 36px;\\n      text-align: center;\\n\\n      color: #242539;\\n    }\\n\\n    .close-modal__button-container {\\n      width: 318px;\\n      display: flex;\\n      flex-flow: row nowrap;\\n      justify-content: space-between;\\n      align-items: center;\\n    }\\n\\n    .close-modal__button {\\n      background: #fff;\\n      border: 2px solid #EDEEF3;\\n      border-radius: 74px;\\n      width: 152px;\\n      height: 56px;\\n      cursor: pointer;\\n      font-weight: 600;\\n      font-size: 14px;\\n      line-height: 21px;\\n      color: #2B2D56;\\n      text-transform: uppercase;\\n    }\\n\\n    .close-modal__button--exit {\\n      background: #DD3E56;\\n      box-shadow: 0px 8px 34px rgba(221, 62, 86, 0.4);\\n      color: #fff;\\n      border-color: transparent;\\n    }\\n  \");\r\n    return styles;\r\n}\n\nvar RampInstantSDK = /** @class */ (function () {\r\n    function RampInstantSDK(config) {\r\n        this._listeners = initEventListenersDict();\r\n        this._isVisible = false;\r\n        this._onSendCryptoCallback = undefined;\r\n        importFonts();\r\n        this.unsubscribe = this.unsubscribe.bind(this);\r\n        this.on = this.on.bind(this);\r\n        this.show = this.show.bind(this);\r\n        this._handleEscapeClick = this._handleEscapeClick.bind(this);\r\n        this._dispatchEvent = this._dispatchEvent.bind(this);\r\n        this._subscribeToWidgetEvents = this._subscribeToWidgetEvents.bind(this);\r\n        this._on = this._on.bind(this);\r\n        this._registerSdkEventHandlers = this._registerSdkEventHandlers.bind(this);\r\n        this._subscribeToWidgetEvents = this._subscribeToWidgetEvents.bind(this);\r\n        this._onSendCrypto = this._onSendCrypto.bind(this);\r\n        this._rawNormalizedConfig = normalizeConfigAndLogErrorsOnInvalidFields(__assign({ variant: 'desktop' }, config));\r\n        this._config = __assign(__assign({}, this._rawNormalizedConfig), this._getHostConfigSdkParams(this._rawNormalizedConfig, config.useSendCryptoCallback));\r\n    }\r\n    RampInstantSDK.prototype.show = function () {\r\n        if (this._isVisible) {\r\n            throw new Error('Widget is already visible - you can only call this once per instance');\r\n        }\r\n        if (document.activeElement && isHtmlElement(document.activeElement)) {\r\n            document.activeElement.blur();\r\n        }\r\n        this._registerSdkEventHandlers();\r\n        window.addEventListener('message', this._subscribeToWidgetEvents);\r\n        if (this._isConfiguredAsHosted()) {\r\n            this._showUsingHostedMode();\r\n        }\r\n        else if (this._isConfiguredAsEmbedded()) {\r\n            this._showUsingEmbeddedMode();\r\n        }\r\n        else if (this._isConfiguredWithOverlay()) {\r\n            this._showUsingOverlayMode();\r\n        }\r\n        window.addEventListener('keydown', this._handleEscapeClick, true);\r\n        return this;\r\n    };\r\n    RampInstantSDK.prototype.on = function (type, callback) {\r\n        this._on(type, callback, false);\r\n        return this;\r\n    };\r\n    RampInstantSDK.prototype.unsubscribe = function (type, callback) {\r\n        var _this = this;\r\n        if (type === '*') {\r\n            var allTypes = Object.entries(this._listeners);\r\n            allTypes.forEach(function (_a) {\r\n                var key = _a[0], eventHandlers = _a[1];\r\n                var filteredHandlers = eventHandlers.filter(function (l) { return l.callback !== callback; });\r\n                _this._listeners[key] = filteredHandlers;\r\n            });\r\n        }\r\n        else {\r\n            this._listeners[type] = this._listeners[type].filter(function (l) { return l.callback !== callback; });\r\n        }\r\n        return this;\r\n    };\r\n    RampInstantSDK.prototype._on = function (type, callback, internal) {\r\n        if (type !== '*' && !this._listeners[type]) {\r\n            // tslint:disable-next-line:no-console\r\n            console.warn(\"Unknown / unsupported event name - '\".concat(type, \"'. This listener will have no effect.\"));\r\n        }\r\n        if (type === '*') {\r\n            var allTypes = Object.values(this._listeners);\r\n            allTypes.forEach(function (eventHandlers) { return eventHandlers.push({ callback: callback, internal: internal }); });\r\n        }\r\n        else {\r\n            this._listeners[type].push({ callback: callback, internal: internal });\r\n        }\r\n    };\r\n    RampInstantSDK.prototype.close = function () {\r\n        this._dispatchEvent({\r\n            type: WidgetEventTypes.WIDGET_CLOSE,\r\n            payload: null,\r\n            widgetInstanceId: this._config.widgetInstanceId,\r\n        });\r\n        return this;\r\n    };\r\n    RampInstantSDK.prototype.onSendCrypto = function (callback) {\r\n        this._onSendCryptoCallback = callback;\r\n        return this;\r\n    };\r\n    RampInstantSDK.prototype.onRequestCryptoAccount = function (callback) {\r\n        var _this = this;\r\n        var onRequestCryptoAccount = function (event) { return __awaiter(_this, void 0, void 0, function () {\r\n            var result, e_1, errorMessage;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        _a.trys.push([0, 2, , 3]);\r\n                        return [4 /*yield*/, callback(event.payload.type, event.payload.assetSymbol)];\r\n                    case 1:\r\n                        result = _a.sent();\r\n                        if (!result.address) {\r\n                            throw new Error('Missing address in the callback result');\r\n                        }\r\n                        return [3 /*break*/, 3];\r\n                    case 2:\r\n                        e_1 = _a.sent();\r\n                        errorMessage = void 0;\r\n                        if (typeof e_1 === 'string') {\r\n                            errorMessage = e_1;\r\n                        }\r\n                        else if (e_1 instanceof Error) {\r\n                            errorMessage = e_1.message;\r\n                        }\r\n                        this._sendEventToWidget({\r\n                            type: InternalSdkEventTypes.REQUEST_CRYPTO_ACCOUNT_RESULT,\r\n                            payload: {\r\n                                error: errorMessage,\r\n                            },\r\n                        });\r\n                        return [2 /*return*/];\r\n                    case 3:\r\n                        this._sendEventToWidget({\r\n                            type: InternalSdkEventTypes.REQUEST_CRYPTO_ACCOUNT_RESULT,\r\n                            payload: {\r\n                                address: result.address,\r\n                                type: result.type,\r\n                                name: result.name,\r\n                                assetSymbol: result.assetSymbol,\r\n                            },\r\n                        });\r\n                        return [2 /*return*/];\r\n                }\r\n            });\r\n        }); };\r\n        this._on(InternalEventTypes.REQUEST_CRYPTO_ACCOUNT, onRequestCryptoAccount, true);\r\n        return this;\r\n    };\r\n    RampInstantSDK.prototype._subscribeToWidgetEvents = function (event) {\r\n        if (!event.data) {\r\n            return;\r\n        }\r\n        if (!areUrlsEqual(event.origin, getBaseUrl(this._config).origin)) {\r\n            return;\r\n        }\r\n        var eventData = event.data;\r\n        if (!eventData.widgetInstanceId ||\r\n            eventData.widgetInstanceId !== this._config.widgetInstanceId) {\r\n            return;\r\n        }\r\n        this._dispatchEvent(eventData);\r\n    };\r\n    RampInstantSDK.prototype._registerSdkEventHandlers = function () {\r\n        var _this = this;\r\n        this._on(WidgetEventTypes.WIDGET_CLOSE, function (_event) {\r\n            var _a, _b;\r\n            if (_this._isConfiguredAsHosted()) {\r\n                try {\r\n                    (_a = _this.widgetWindow) === null || _a === void 0 ? void 0 : _a.close();\r\n                }\r\n                catch (e) {\r\n                    throw new Error('Could not close the widget window');\r\n                }\r\n            }\r\n            else {\r\n                (_b = _this.domNodes) === null || _b === void 0 ? void 0 : _b.shadowHost.remove();\r\n                clearAllBodyScrollLocks();\r\n            }\r\n            _this._teardownEventSubscriptions();\r\n        }, true);\r\n        var onConfigEvent = function () {\r\n            var _a, _b;\r\n            if (_this._isConfiguredAsHosted()) {\r\n                return;\r\n            }\r\n            (_a = _this.domNodes) === null || _a === void 0 ? void 0 : _a.iframe.classList.add('visible');\r\n            var loader = (_b = _this.domNodes) === null || _b === void 0 ? void 0 : _b.shadow.querySelector('.loader-container');\r\n            if (loader) {\r\n                loader.remove();\r\n            }\r\n        };\r\n        if (this._config.useSendCryptoCallbackVersion) {\r\n            this.on(InternalEventTypes.SEND_CRYPTO, this._onSendCrypto);\r\n        }\r\n        this._on(WidgetEventTypes.WIDGET_CONFIG_DONE, onConfigEvent, true);\r\n        this._on(WidgetEventTypes.WIDGET_CONFIG_FAILED, onConfigEvent, true);\r\n        this._on(InternalEventTypes.WIDGET_CLOSE_REQUEST, function (_event) {\r\n            if (_this._isConfiguredAsHosted() || _this._isConfiguredAsEmbedded()) {\r\n                return;\r\n            }\r\n            if (_this._config.variant === 'mobile' || isCloseModalAlreadyOpen(_this.domNodes.overlay)) {\r\n                return;\r\n            }\r\n            _this.domNodes.overlay.appendChild(prepareCloseModalNode(_this._dispatchEvent));\r\n        }, true);\r\n        this._on(InternalEventTypes.WIDGET_CLOSE_REQUEST_CONFIRMED, function (_event) {\r\n            _this._dispatchEvent({\r\n                type: WidgetEventTypes.WIDGET_CLOSE,\r\n                payload: null,\r\n                widgetInstanceId: _this._config.widgetInstanceId,\r\n            });\r\n        }, true);\r\n        this._on(InternalEventTypes.WIDGET_CLOSE_REQUEST_CANCELLED, function (_event) {\r\n            if (_this._isConfiguredAsHosted() || _this._isConfiguredAsEmbedded()) {\r\n                return;\r\n            }\r\n            var modal = _this.domNodes.overlay.querySelector('.close-modal');\r\n            if (modal) {\r\n                modal.remove();\r\n            }\r\n        }, true);\r\n    };\r\n    RampInstantSDK.prototype._sendEventToWidget = function (event) {\r\n        var _a, _b, _c;\r\n        if (!this._isVisible) {\r\n            throw new Error(\"Widget is not visible couldn't send the event\");\r\n        }\r\n        try {\r\n            (_c = ((_a = this.widgetWindow) !== null && _a !== void 0 ? _a : (_b = this.domNodes) === null || _b === void 0 ? void 0 : _b.iframe.contentWindow)) === null || _c === void 0 ? void 0 : _c.postMessage(event, getBaseUrl(this._config).origin);\r\n            // tslint:disable-next-line:no-empty\r\n        }\r\n        catch (_d) { }\r\n    };\r\n    RampInstantSDK.prototype._dispatchEvent = function (event) {\r\n        var type = event.type;\r\n        this._listeners[type].forEach(function (handler) { return handler.callback(event); });\r\n    };\r\n    RampInstantSDK.prototype._handleEscapeClick = function (event) {\r\n        var escKeyCode = 27;\r\n        if (event.key === 'Escape' || event.key === 'Esc' || event.keyCode === escKeyCode) {\r\n            this._dispatchEvent({\r\n                type: InternalEventTypes.WIDGET_CLOSE_REQUEST,\r\n                payload: null,\r\n                internal: true,\r\n            });\r\n        }\r\n    };\r\n    RampInstantSDK.prototype._onSendCrypto = function (event) {\r\n        var _a;\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var result, e_2, errorMessage;\r\n            return __generator(this, function (_b) {\r\n                switch (_b.label) {\r\n                    case 0:\r\n                        if (event.eventVersion !== SEND_CRYPTO_SUPPORTED_VERSION) {\r\n                            // tslint:disable-next-line:no-console\r\n                            console.warn(\"unsupported event version - '\".concat(event, \"'. This listener will have no effect.\"));\r\n                            return [2 /*return*/];\r\n                        }\r\n                        _b.label = 1;\r\n                    case 1:\r\n                        _b.trys.push([1, 3, , 4]);\r\n                        return [4 /*yield*/, ((_a = this._onSendCryptoCallback) === null || _a === void 0 ? void 0 : _a.call(this, event.payload.assetInfo, event.payload.amount, event.payload.address))];\r\n                    case 2:\r\n                        result = _b.sent();\r\n                        if (!(result === null || result === void 0 ? void 0 : result.txHash)) {\r\n                            throw new Error('Missing txHash in the callback result');\r\n                        }\r\n                        return [3 /*break*/, 4];\r\n                    case 3:\r\n                        e_2 = _b.sent();\r\n                        errorMessage = void 0;\r\n                        if (typeof e_2 === 'string') {\r\n                            errorMessage = e_2;\r\n                        }\r\n                        else if (e_2 instanceof Error) {\r\n                            errorMessage = e_2.message;\r\n                        }\r\n                        this._sendEventToWidget({\r\n                            eventVersion: SEND_CRYPTO_SUPPORTED_VERSION,\r\n                            type: InternalSdkEventTypes.SEND_CRYPTO_RESULT,\r\n                            payload: {\r\n                                error: errorMessage,\r\n                            },\r\n                        });\r\n                        return [2 /*return*/];\r\n                    case 4:\r\n                        this._sendEventToWidget({\r\n                            eventVersion: SEND_CRYPTO_SUPPORTED_VERSION,\r\n                            type: InternalSdkEventTypes.SEND_CRYPTO_RESULT,\r\n                            payload: {\r\n                                txHash: result.txHash,\r\n                            },\r\n                        });\r\n                        return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    // Event subscriptions aren't cleared so that host can receive a PAYMENT_SUCCESSFUL event\r\n    // even after the widget has been closed\r\n    RampInstantSDK.prototype._teardownEventSubscriptions = function () {\r\n        window.removeEventListener('keydown', this._handleEscapeClick, true);\r\n        window.removeEventListener('message', this._subscribeToWidgetEvents);\r\n    };\r\n    RampInstantSDK.prototype._showUsingEmbeddedMode = function () {\r\n        var _a, _b;\r\n        var widgetUrl = initWidgetIframeUrl(this._config);\r\n        this.domNodes = initDOMNodeWithoutOverlay(widgetUrl, this._dispatchEvent, this._config);\r\n        if (!((_a = this.domNodes) === null || _a === void 0 ? void 0 : _a.body)) {\r\n            throw new Error(\"Couldn't find <body> element.\");\r\n        }\r\n        (_b = this._config.containerNode) === null || _b === void 0 ? void 0 : _b.appendChild(this.domNodes.shadowHost);\r\n        this._isVisible = true;\r\n    };\r\n    RampInstantSDK.prototype._showUsingOverlayMode = function () {\r\n        var _a;\r\n        var widgetUrl = initWidgetIframeUrl(this._config);\r\n        this.domNodes = initDOMNodeWithOverlay(widgetUrl, this._dispatchEvent, this._config);\r\n        if (!((_a = this.domNodes) === null || _a === void 0 ? void 0 : _a.body)) {\r\n            throw new Error(\"Couldn't find <body> element.\");\r\n        }\r\n        this.domNodes.body.appendChild(this.domNodes.shadowHost);\r\n        this._isVisible = true;\r\n        disableBodyScroll(this.domNodes.iframe);\r\n        var widgetMode = determineWidgetVariant(this._config);\r\n        if (widgetMode !== 'desktop' && widgetMode !== 'embedded-desktop') {\r\n            hideWebsiteBelow(this.domNodes.shadow);\r\n        }\r\n    };\r\n    RampInstantSDK.prototype._showUsingHostedMode = function () {\r\n        var _a;\r\n        var widgetUrl = initWidgetIframeUrl(this._config);\r\n        this.widgetWindow = (_a = window.open(widgetUrl)) !== null && _a !== void 0 ? _a : undefined;\r\n    };\r\n    RampInstantSDK.prototype._isConfiguredWithOverlay = function () {\r\n        return ['desktop', 'mobile'].includes(this._config.variant);\r\n    };\r\n    RampInstantSDK.prototype._isConfiguredAsHosted = function () {\r\n        return ['hosted-desktop', 'hosted-mobile'].includes(this._config.variant);\r\n    };\r\n    RampInstantSDK.prototype._isConfiguredAsEmbedded = function () {\r\n        return ['embedded-desktop', 'embedded-mobile'].includes(this._rawNormalizedConfig.variant);\r\n    };\r\n    RampInstantSDK.prototype._getHostConfigSdkParams = function (config, useSendCryptoCallback) {\r\n        var widgetVariant = determineWidgetVariant(config);\r\n        return __assign({ sdkType: 'WEB', sdkVersion: SDK_VERSION, variant: widgetVariant, widgetInstanceId: getRandomIntString() }, (useSendCryptoCallback\r\n            ? { useSendCryptoCallbackVersion: SEND_CRYPTO_SUPPORTED_VERSION }\r\n            : {}));\r\n    };\r\n    return RampInstantSDK;\r\n}());\n\n\n//# sourceMappingURL=ramp-instant-sdk.es5.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJhbXAtbmV0d29yay9yYW1wLWluc3RhbnQtc2RrL2Rpc3QvcmFtcC1pbnN0YW50LXNkay5lczUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsT0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxjQUFjO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsY0FBYyw2QkFBNkIsMEJBQTBCLGNBQWMscUJBQXFCO0FBQ3hHLGlCQUFpQixvREFBb0QscUVBQXFFLGNBQWM7QUFDeEosdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEMsbUNBQW1DLFNBQVM7QUFDNUMsbUNBQW1DLFdBQVcsVUFBVTtBQUN4RCwwQ0FBMEMsY0FBYztBQUN4RDtBQUNBLDhHQUE4RyxPQUFPO0FBQ3JILGlGQUFpRixpQkFBaUI7QUFDbEcseURBQXlELGdCQUFnQixRQUFRO0FBQ2pGLCtDQUErQyxnQkFBZ0IsZ0JBQWdCO0FBQy9FO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSxVQUFVLFlBQVksYUFBYSxTQUFTLFVBQVU7QUFDdEQsb0NBQW9DLFNBQVM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsT0FBTztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUMsMEJBQTBCLDBDQUEwQyxnQkFBZ0IsT0FBTyxvQkFBb0IsZUFBZSxPQUFPOztBQUV4Szs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxnRkFBZ0YsZ0JBQWdCO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrRkFBa0YsaUJBQWlCO0FBQ25HO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxxRkFBcUYsaUJBQWlCO0FBQ3RHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4Q0FBOEM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4Q0FBOEM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdDQUF3QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzQ0FBc0M7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRDQUE0QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0RBQWdEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzREFBc0Q7O0FBRXZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssSUFBSTtBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFlBQVk7QUFDdEMsNkNBQTZDLDZCQUE2QixrQkFBa0I7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsY0FBYztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsY0FBYztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxZQUFZLFFBQVEsZ0JBQWdCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELG9CQUFvQixxQkFBcUIscUJBQXFCLHdCQUF3QixrQkFBa0IsbUNBQW1DLGtDQUFrQyxxQkFBcUIsT0FBTyxrQkFBa0Isd0JBQXdCLHNCQUFzQixxQkFBcUIsMENBQTBDLFdBQVcsbUJBQW1CLGdCQUFnQix5QkFBeUIsbURBQW1ELHNCQUFzQiw4QkFBOEIsZ0NBQWdDLHNEQUFzRCx5QkFBeUIsV0FBVyw2QkFBNkIsc0JBQXNCLDJCQUEyQixvQkFBb0IscUJBQXFCLHNCQUFzQiw4QkFBOEIsZ0NBQWdDLHNEQUFzRCx5QkFBeUIsMkZBQTJGLDBGQUEwRixPQUFPLDJCQUEyQiwyQkFBMkIsT0FBTyxpQkFBaUIsaUNBQWlDLG9EQUFvRCxxQkFBcUIscUJBQXFCLDJCQUEyQixPQUFPLG1DQUFtQyxpQ0FBaUMsMkJBQTJCLE9BQU8sbUNBQW1DLGlDQUFpQywyQkFBMkIsb0RBQW9ELDhDQUE4QyxPQUFPLG1DQUFtQyxpQ0FBaUMsMkJBQTJCLG9EQUFvRCwrQ0FBK0MsT0FBTyxrQ0FBa0MsYUFBYSxvQ0FBb0MsU0FBUyxZQUFZLG9DQUFvQyxTQUFTLGFBQWEsb0NBQW9DLFNBQVMsYUFBYSxvQ0FBb0MsU0FBUyxjQUFjLG9DQUFvQyxTQUFTLE9BQU8sa0NBQWtDLGlCQUFpQixnREFBZ0QsU0FBUyxrQkFBa0IsNENBQTRDLFNBQVMsYUFBYSxnREFBZ0QsU0FBUyxPQUFPLG9DQUFvQyxpQkFBaUIsaURBQWlELFNBQVMsa0JBQWtCLDRDQUE0QyxTQUFTLGFBQWEsaURBQWlELFNBQVMsT0FBTyxpQkFBaUIscUJBQXFCLDBCQUEwQiwyQkFBMkIsMkJBQTJCLGlDQUFpQyxPQUFPLHlCQUF5Qiw0QkFBNEI7QUFDbjRGLGtDQUFrQyx1QkFBdUI7QUFDekQsc0JBQXNCLHNCQUFzQiwyQ0FBMkMscUJBQXFCLHNCQUFzQiwyQkFBMkIsa0JBQWtCLGlCQUFpQix5Q0FBeUMsc0JBQXNCLHlEQUF5RCxzQkFBc0IsaUNBQWlDLG9DQUFvQyw0QkFBNEIsc0JBQXNCLDJCQUEyQix5QkFBeUIsaUNBQWlDLE9BQU8sd0JBQXdCLCtCQUErQixPQUFPLDRCQUE0QiwrQkFBK0IseUJBQXlCLHdCQUF3QiwwQkFBMEIsMkJBQTJCLHlCQUF5QixPQUFPLHdDQUF3QyxxQkFBcUIsc0JBQXNCLDhCQUE4Qix1Q0FBdUMsNEJBQTRCLE9BQU8sOEJBQThCLHlCQUF5QixrQ0FBa0MsNEJBQTRCLHFCQUFxQixxQkFBcUIsd0JBQXdCLHlCQUF5Qix3QkFBd0IsMEJBQTBCLHVCQUF1QixrQ0FBa0MsT0FBTyxvQ0FBb0MsNEJBQTRCLHdEQUF3RCxvQkFBb0Isa0NBQWtDLE9BQU87QUFDbDlDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRkFBMEYsb0JBQW9CO0FBQzlHLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLGlDQUFpQztBQUM1RztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsZ0ZBQWdGLGlDQUFpQztBQUNqSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCw0QkFBNEIsd0NBQXdDLElBQUk7QUFDaEk7QUFDQTtBQUNBLHlDQUF5Qyx3Q0FBd0M7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3Qix5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELGlDQUFpQztBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIseUdBQXlHO0FBQ25JLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLENBQUM7O0FBRW9FO0FBQ3JFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJlZ2VuLWV4YW1wbGUvLi9ub2RlX21vZHVsZXMvQHJhbXAtbmV0d29yay9yYW1wLWluc3RhbnQtc2RrL2Rpc3QvcmFtcC1pbnN0YW50LXNkay5lczUuanM/YWE0MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBWZXJzaW9uOiA0LjAuNSAtIE1hcmNoIDI3LCAyMDI0IDEwOjU2OjI1ICovXG4vKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG5cclxudmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XHJcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XHJcbiAgICB2YXIgdCA9IHt9O1xyXG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXHJcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgICAgICB9XHJcbiAgICByZXR1cm4gdDtcclxufVxyXG5cclxuZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gX19nZW5lcmF0b3IodGhpc0FyZywgYm9keSkge1xyXG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xyXG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xyXG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fc3ByZWFkQXJyYXkodG8sIGZyb20sIHBhY2spIHtcclxuICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xyXG4gICAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xyXG4gICAgICAgICAgICBhcltpXSA9IGZyb21baV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XHJcbn1cblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfSBlbHNlIHsgcmV0dXJuIEFycmF5LmZyb20oYXJyKTsgfSB9XG5cbi8vIE9sZGVyIGJyb3dzZXJzIGRvbid0IHN1cHBvcnQgZXZlbnQgb3B0aW9ucywgZmVhdHVyZSBkZXRlY3QgaXQuXG5cbi8vIEFkb3B0ZWQgYW5kIG1vZGlmaWVkIHNvbHV0aW9uIGZyb20gQm9oZGFuIERpZHVraCAoMjAxNylcbi8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzQxNTk0OTk3L2lvcy0xMC1zYWZhcmktcHJldmVudC1zY3JvbGxpbmctYmVoaW5kLWEtZml4ZWQtb3ZlcmxheS1hbmQtbWFpbnRhaW4tc2Nyb2xsLXBvc2lcblxudmFyIGhhc1Bhc3NpdmVFdmVudHMgPSBmYWxzZTtcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICB2YXIgcGFzc2l2ZVRlc3RPcHRpb25zID0ge1xuICAgIGdldCBwYXNzaXZlKCkge1xuICAgICAgaGFzUGFzc2l2ZUV2ZW50cyA9IHRydWU7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgfTtcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3RQYXNzaXZlJywgbnVsbCwgcGFzc2l2ZVRlc3RPcHRpb25zKTtcbiAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Rlc3RQYXNzaXZlJywgbnVsbCwgcGFzc2l2ZVRlc3RPcHRpb25zKTtcbn1cblxudmFyIGlzSW9zRGV2aWNlID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lm5hdmlnYXRvciAmJiB3aW5kb3cubmF2aWdhdG9yLnBsYXRmb3JtICYmICgvaVAoYWR8aG9uZXxvZCkvLnRlc3Qod2luZG93Lm5hdmlnYXRvci5wbGF0Zm9ybSkgfHwgd2luZG93Lm5hdmlnYXRvci5wbGF0Zm9ybSA9PT0gJ01hY0ludGVsJyAmJiB3aW5kb3cubmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzID4gMSk7XG5cblxudmFyIGxvY2tzID0gW107XG52YXIgZG9jdW1lbnRMaXN0ZW5lckFkZGVkID0gZmFsc2U7XG52YXIgaW5pdGlhbENsaWVudFkgPSAtMTtcbnZhciBwcmV2aW91c0JvZHlPdmVyZmxvd1NldHRpbmcgPSB2b2lkIDA7XG52YXIgcHJldmlvdXNCb2R5UGFkZGluZ1JpZ2h0ID0gdm9pZCAwO1xuXG4vLyByZXR1cm5zIHRydWUgaWYgYGVsYCBzaG91bGQgYmUgYWxsb3dlZCB0byByZWNlaXZlIHRvdWNobW92ZSBldmVudHMuXG52YXIgYWxsb3dUb3VjaE1vdmUgPSBmdW5jdGlvbiBhbGxvd1RvdWNoTW92ZShlbCkge1xuICByZXR1cm4gbG9ja3Muc29tZShmdW5jdGlvbiAobG9jaykge1xuICAgIGlmIChsb2NrLm9wdGlvbnMuYWxsb3dUb3VjaE1vdmUgJiYgbG9jay5vcHRpb25zLmFsbG93VG91Y2hNb3ZlKGVsKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9KTtcbn07XG5cbnZhciBwcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KHJhd0V2ZW50KSB7XG4gIHZhciBlID0gcmF3RXZlbnQgfHwgd2luZG93LmV2ZW50O1xuXG4gIC8vIEZvciB0aGUgY2FzZSB3aGVyZWJ5IGNvbnN1bWVycyBhZGRzIGEgdG91Y2htb3ZlIGV2ZW50IGxpc3RlbmVyIHRvIGRvY3VtZW50LlxuICAvLyBSZWNhbGwgdGhhdCB3ZSBkbyBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBwcmV2ZW50RGVmYXVsdCwgeyBwYXNzaXZlOiBmYWxzZSB9KVxuICAvLyBpbiBkaXNhYmxlQm9keVNjcm9sbCAtIHNvIGlmIHdlIHByb3ZpZGUgdGhpcyBvcHBvcnR1bml0eSB0byBhbGxvd1RvdWNoTW92ZSwgdGhlblxuICAvLyB0aGUgdG91Y2htb3ZlIGV2ZW50IG9uIGRvY3VtZW50IHdpbGwgYnJlYWsuXG4gIGlmIChhbGxvd1RvdWNoTW92ZShlLnRhcmdldCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIERvIG5vdCBwcmV2ZW50IGlmIHRoZSBldmVudCBoYXMgbW9yZSB0aGFuIG9uZSB0b3VjaCAodXN1YWxseSBtZWFuaW5nIHRoaXMgaXMgYSBtdWx0aSB0b3VjaCBnZXN0dXJlIGxpa2UgcGluY2ggdG8gem9vbSkuXG4gIGlmIChlLnRvdWNoZXMubGVuZ3RoID4gMSkgcmV0dXJuIHRydWU7XG5cbiAgaWYgKGUucHJldmVudERlZmF1bHQpIGUucHJldmVudERlZmF1bHQoKTtcblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG52YXIgc2V0T3ZlcmZsb3dIaWRkZW4gPSBmdW5jdGlvbiBzZXRPdmVyZmxvd0hpZGRlbihvcHRpb25zKSB7XG4gIC8vIElmIHByZXZpb3VzQm9keVBhZGRpbmdSaWdodCBpcyBhbHJlYWR5IHNldCwgZG9uJ3Qgc2V0IGl0IGFnYWluLlxuICBpZiAocHJldmlvdXNCb2R5UGFkZGluZ1JpZ2h0ID09PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgX3Jlc2VydmVTY3JvbGxCYXJHYXAgPSAhIW9wdGlvbnMgJiYgb3B0aW9ucy5yZXNlcnZlU2Nyb2xsQmFyR2FwID09PSB0cnVlO1xuICAgIHZhciBzY3JvbGxCYXJHYXAgPSB3aW5kb3cuaW5uZXJXaWR0aCAtIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aDtcblxuICAgIGlmIChfcmVzZXJ2ZVNjcm9sbEJhckdhcCAmJiBzY3JvbGxCYXJHYXAgPiAwKSB7XG4gICAgICBwcmV2aW91c0JvZHlQYWRkaW5nUmlnaHQgPSBkb2N1bWVudC5ib2R5LnN0eWxlLnBhZGRpbmdSaWdodDtcbiAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUucGFkZGluZ1JpZ2h0ID0gc2Nyb2xsQmFyR2FwICsgJ3B4JztcbiAgICB9XG4gIH1cblxuICAvLyBJZiBwcmV2aW91c0JvZHlPdmVyZmxvd1NldHRpbmcgaXMgYWxyZWFkeSBzZXQsIGRvbid0IHNldCBpdCBhZ2Fpbi5cbiAgaWYgKHByZXZpb3VzQm9keU92ZXJmbG93U2V0dGluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcHJldmlvdXNCb2R5T3ZlcmZsb3dTZXR0aW5nID0gZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvdztcbiAgICBkb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG4gIH1cbn07XG5cbnZhciByZXN0b3JlT3ZlcmZsb3dTZXR0aW5nID0gZnVuY3Rpb24gcmVzdG9yZU92ZXJmbG93U2V0dGluZygpIHtcbiAgaWYgKHByZXZpb3VzQm9keVBhZGRpbmdSaWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZG9jdW1lbnQuYm9keS5zdHlsZS5wYWRkaW5nUmlnaHQgPSBwcmV2aW91c0JvZHlQYWRkaW5nUmlnaHQ7XG5cbiAgICAvLyBSZXN0b3JlIHByZXZpb3VzQm9keVBhZGRpbmdSaWdodCB0byB1bmRlZmluZWQgc28gc2V0T3ZlcmZsb3dIaWRkZW4ga25vd3MgaXRcbiAgICAvLyBjYW4gYmUgc2V0IGFnYWluLlxuICAgIHByZXZpb3VzQm9keVBhZGRpbmdSaWdodCA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmIChwcmV2aW91c0JvZHlPdmVyZmxvd1NldHRpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGRvY3VtZW50LmJvZHkuc3R5bGUub3ZlcmZsb3cgPSBwcmV2aW91c0JvZHlPdmVyZmxvd1NldHRpbmc7XG5cbiAgICAvLyBSZXN0b3JlIHByZXZpb3VzQm9keU92ZXJmbG93U2V0dGluZyB0byB1bmRlZmluZWRcbiAgICAvLyBzbyBzZXRPdmVyZmxvd0hpZGRlbiBrbm93cyBpdCBjYW4gYmUgc2V0IGFnYWluLlxuICAgIHByZXZpb3VzQm9keU92ZXJmbG93U2V0dGluZyA9IHVuZGVmaW5lZDtcbiAgfVxufTtcblxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VsZW1lbnQvc2Nyb2xsSGVpZ2h0I1Byb2JsZW1zX2FuZF9zb2x1dGlvbnNcbnZhciBpc1RhcmdldEVsZW1lbnRUb3RhbGx5U2Nyb2xsZWQgPSBmdW5jdGlvbiBpc1RhcmdldEVsZW1lbnRUb3RhbGx5U2Nyb2xsZWQodGFyZ2V0RWxlbWVudCkge1xuICByZXR1cm4gdGFyZ2V0RWxlbWVudCA/IHRhcmdldEVsZW1lbnQuc2Nyb2xsSGVpZ2h0IC0gdGFyZ2V0RWxlbWVudC5zY3JvbGxUb3AgPD0gdGFyZ2V0RWxlbWVudC5jbGllbnRIZWlnaHQgOiBmYWxzZTtcbn07XG5cbnZhciBoYW5kbGVTY3JvbGwgPSBmdW5jdGlvbiBoYW5kbGVTY3JvbGwoZXZlbnQsIHRhcmdldEVsZW1lbnQpIHtcbiAgdmFyIGNsaWVudFkgPSBldmVudC50YXJnZXRUb3VjaGVzWzBdLmNsaWVudFkgLSBpbml0aWFsQ2xpZW50WTtcblxuICBpZiAoYWxsb3dUb3VjaE1vdmUoZXZlbnQudGFyZ2V0KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh0YXJnZXRFbGVtZW50ICYmIHRhcmdldEVsZW1lbnQuc2Nyb2xsVG9wID09PSAwICYmIGNsaWVudFkgPiAwKSB7XG4gICAgLy8gZWxlbWVudCBpcyBhdCB0aGUgdG9wIG9mIGl0cyBzY3JvbGwuXG4gICAgcmV0dXJuIHByZXZlbnREZWZhdWx0KGV2ZW50KTtcbiAgfVxuXG4gIGlmIChpc1RhcmdldEVsZW1lbnRUb3RhbGx5U2Nyb2xsZWQodGFyZ2V0RWxlbWVudCkgJiYgY2xpZW50WSA8IDApIHtcbiAgICAvLyBlbGVtZW50IGlzIGF0IHRoZSBib3R0b20gb2YgaXRzIHNjcm9sbC5cbiAgICByZXR1cm4gcHJldmVudERlZmF1bHQoZXZlbnQpO1xuICB9XG5cbiAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIHJldHVybiB0cnVlO1xufTtcblxudmFyIGRpc2FibGVCb2R5U2Nyb2xsID0gZnVuY3Rpb24gZGlzYWJsZUJvZHlTY3JvbGwodGFyZ2V0RWxlbWVudCwgb3B0aW9ucykge1xuICAvLyB0YXJnZXRFbGVtZW50IG11c3QgYmUgcHJvdmlkZWRcbiAgaWYgKCF0YXJnZXRFbGVtZW50KSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICBjb25zb2xlLmVycm9yKCdkaXNhYmxlQm9keVNjcm9sbCB1bnN1Y2Nlc3NmdWwgLSB0YXJnZXRFbGVtZW50IG11c3QgYmUgcHJvdmlkZWQgd2hlbiBjYWxsaW5nIGRpc2FibGVCb2R5U2Nyb2xsIG9uIElPUyBkZXZpY2VzLicpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGRpc2FibGVCb2R5U2Nyb2xsIG11c3Qgbm90IGhhdmUgYmVlbiBjYWxsZWQgb24gdGhpcyB0YXJnZXRFbGVtZW50IGJlZm9yZVxuICBpZiAobG9ja3Muc29tZShmdW5jdGlvbiAobG9jaykge1xuICAgIHJldHVybiBsb2NrLnRhcmdldEVsZW1lbnQgPT09IHRhcmdldEVsZW1lbnQ7XG4gIH0pKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGxvY2sgPSB7XG4gICAgdGFyZ2V0RWxlbWVudDogdGFyZ2V0RWxlbWVudCxcbiAgICBvcHRpb25zOiBvcHRpb25zIHx8IHt9XG4gIH07XG5cbiAgbG9ja3MgPSBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGxvY2tzKSwgW2xvY2tdKTtcblxuICBpZiAoaXNJb3NEZXZpY2UpIHtcbiAgICB0YXJnZXRFbGVtZW50Lm9udG91Y2hzdGFydCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgaWYgKGV2ZW50LnRhcmdldFRvdWNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIC8vIGRldGVjdCBzaW5nbGUgdG91Y2guXG4gICAgICAgIGluaXRpYWxDbGllbnRZID0gZXZlbnQudGFyZ2V0VG91Y2hlc1swXS5jbGllbnRZO1xuICAgICAgfVxuICAgIH07XG4gICAgdGFyZ2V0RWxlbWVudC5vbnRvdWNobW92ZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgaWYgKGV2ZW50LnRhcmdldFRvdWNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIC8vIGRldGVjdCBzaW5nbGUgdG91Y2guXG4gICAgICAgIGhhbmRsZVNjcm9sbChldmVudCwgdGFyZ2V0RWxlbWVudCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmICghZG9jdW1lbnRMaXN0ZW5lckFkZGVkKSB7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBwcmV2ZW50RGVmYXVsdCwgaGFzUGFzc2l2ZUV2ZW50cyA/IHsgcGFzc2l2ZTogZmFsc2UgfSA6IHVuZGVmaW5lZCk7XG4gICAgICBkb2N1bWVudExpc3RlbmVyQWRkZWQgPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzZXRPdmVyZmxvd0hpZGRlbihvcHRpb25zKTtcbiAgfVxufTtcblxudmFyIGNsZWFyQWxsQm9keVNjcm9sbExvY2tzID0gZnVuY3Rpb24gY2xlYXJBbGxCb2R5U2Nyb2xsTG9ja3MoKSB7XG4gIGlmIChpc0lvc0RldmljZSkge1xuICAgIC8vIENsZWFyIGFsbCBsb2NrcyBvbnRvdWNoc3RhcnQvb250b3VjaG1vdmUgaGFuZGxlcnMsIGFuZCB0aGUgcmVmZXJlbmNlcy5cbiAgICBsb2Nrcy5mb3JFYWNoKGZ1bmN0aW9uIChsb2NrKSB7XG4gICAgICBsb2NrLnRhcmdldEVsZW1lbnQub250b3VjaHN0YXJ0ID0gbnVsbDtcbiAgICAgIGxvY2sudGFyZ2V0RWxlbWVudC5vbnRvdWNobW92ZSA9IG51bGw7XG4gICAgfSk7XG5cbiAgICBpZiAoZG9jdW1lbnRMaXN0ZW5lckFkZGVkKSB7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBwcmV2ZW50RGVmYXVsdCwgaGFzUGFzc2l2ZUV2ZW50cyA/IHsgcGFzc2l2ZTogZmFsc2UgfSA6IHVuZGVmaW5lZCk7XG4gICAgICBkb2N1bWVudExpc3RlbmVyQWRkZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBSZXNldCBpbml0aWFsIGNsaWVudFkuXG4gICAgaW5pdGlhbENsaWVudFkgPSAtMTtcbiAgfSBlbHNlIHtcbiAgICByZXN0b3JlT3ZlcmZsb3dTZXR0aW5nKCk7XG4gIH1cblxuICBsb2NrcyA9IFtdO1xufTtcblxudmFyIGJhc2VXaWRnZXRVcmwgPSAnaHR0cHM6Ly9hcHAucmFtcC5uZXR3b3JrLyc7XHJcbnZhciBTRU5EX0NSWVBUT19TVVBQT1JURURfVkVSU0lPTiA9IDE7XHJcbi8vIEl0IHdpbGwgYmUgZXZhbHVhdGVkIGJ5IHJvbGx1cC1wbHVnaW4tdmVyc2lvbi1pbmplY3RvclxyXG52YXIgU0RLX1ZFUlNJT04gPSAnNC4wLjUnO1xuXG52YXIgUGF5bWVudE1ldGhvZE5hbWU7XHJcbihmdW5jdGlvbiAoUGF5bWVudE1ldGhvZE5hbWUpIHtcclxuICAgIFBheW1lbnRNZXRob2ROYW1lW1wiTUFOVUFMX0JBTktfVFJBTlNGRVJcIl0gPSBcIk1BTlVBTF9CQU5LX1RSQU5TRkVSXCI7XHJcbiAgICBQYXltZW50TWV0aG9kTmFtZVtcIkFVVE9fQkFOS19UUkFOU0ZFUlwiXSA9IFwiQVVUT19CQU5LX1RSQU5TRkVSXCI7XHJcbiAgICBQYXltZW50TWV0aG9kTmFtZVtcIkNBUkRfUEFZTUVOVFwiXSA9IFwiQ0FSRF9QQVlNRU5UXCI7XHJcbiAgICBQYXltZW50TWV0aG9kTmFtZVtcIkFQUExFX1BBWVwiXSA9IFwiQVBQTEVfUEFZXCI7XHJcbn0pKFBheW1lbnRNZXRob2ROYW1lIHx8IChQYXltZW50TWV0aG9kTmFtZSA9IHt9KSk7XHJcbnZhciBQYXltZW50TWV0aG9kVHlwZTtcclxuKGZ1bmN0aW9uIChQYXltZW50TWV0aG9kVHlwZSkge1xyXG4gICAgUGF5bWVudE1ldGhvZFR5cGVbXCJTRVBBXCJdID0gXCJTRVBBXCI7XHJcbiAgICBQYXltZW50TWV0aG9kVHlwZVtcIkNBUkRcIl0gPSBcIkNBUkRcIjtcclxuICAgIFBheW1lbnRNZXRob2RUeXBlW1wiQVBQTEVQQVlcIl0gPSBcIkFQUExFUEFZXCI7XHJcbiAgICBQYXltZW50TWV0aG9kVHlwZVtcIkdPT0dMRVBBWVwiXSA9IFwiR09PR0xFUEFZXCI7XHJcbiAgICBQYXltZW50TWV0aG9kVHlwZVtcIlBJU1BcIl0gPSBcIlBJU1BcIjtcclxuICAgIFBheW1lbnRNZXRob2RUeXBlW1wiU09GT1JUXCJdID0gXCJTT0ZPUlRcIjtcclxuICAgIFBheW1lbnRNZXRob2RUeXBlW1wiUElYXCJdID0gXCJQSVhcIjtcclxufSkoUGF5bWVudE1ldGhvZFR5cGUgfHwgKFBheW1lbnRNZXRob2RUeXBlID0ge30pKTtcclxudmFyIFB1cmNoYXNlU3RhdHVzO1xyXG4oZnVuY3Rpb24gKFB1cmNoYXNlU3RhdHVzKSB7XHJcbiAgICBQdXJjaGFzZVN0YXR1c1tcIklOSVRJQUxJWkVEXCJdID0gXCJJTklUSUFMSVpFRFwiO1xyXG4gICAgUHVyY2hhc2VTdGF0dXNbXCJQQVlNRU5UX1NUQVJURURcIl0gPSBcIlBBWU1FTlRfU1RBUlRFRFwiO1xyXG4gICAgUHVyY2hhc2VTdGF0dXNbXCJQQVlNRU5UX0lOX1BST0dSRVNTXCJdID0gXCJQQVlNRU5UX0lOX1BST0dSRVNTXCI7XHJcbiAgICBQdXJjaGFzZVN0YXR1c1tcIlBBWU1FTlRfRkFJTEVEXCJdID0gXCJQQVlNRU5UX0ZBSUxFRFwiO1xyXG4gICAgUHVyY2hhc2VTdGF0dXNbXCJQQVlNRU5UX0VYRUNVVEVEXCJdID0gXCJQQVlNRU5UX0VYRUNVVEVEXCI7XHJcbiAgICBQdXJjaGFzZVN0YXR1c1tcIkZJQVRfUkVDRUlWRURcIl0gPSBcIkZJQVRfUkVDRUlWRURcIjtcclxuICAgIFB1cmNoYXNlU3RhdHVzW1wiRklBVF9TRU5UXCJdID0gXCJGSUFUX1NFTlRcIjtcclxuICAgIFB1cmNoYXNlU3RhdHVzW1wiRVhQSVJFRFwiXSA9IFwiRVhQSVJFRFwiO1xyXG4gICAgUHVyY2hhc2VTdGF0dXNbXCJDQU5DRUxMRURcIl0gPSBcIkNBTkNFTExFRFwiO1xyXG4gICAgUHVyY2hhc2VTdGF0dXNbXCJSRUxFQVNJTkdcIl0gPSBcIlJFTEVBU0lOR1wiO1xyXG4gICAgUHVyY2hhc2VTdGF0dXNbXCJSRUxFQVNFRFwiXSA9IFwiUkVMRUFTRURcIjtcclxufSkoUHVyY2hhc2VTdGF0dXMgfHwgKFB1cmNoYXNlU3RhdHVzID0ge30pKTtcclxudmFyIEV2ZW50U2V2ZXJpdHk7XHJcbihmdW5jdGlvbiAoRXZlbnRTZXZlcml0eSkge1xyXG4gICAgRXZlbnRTZXZlcml0eVtcIlZFUkJPU0VcIl0gPSBcIlZFUkJPU0VcIjtcclxuICAgIEV2ZW50U2V2ZXJpdHlbXCJERUJVR1wiXSA9IFwiREVCVUdcIjtcclxuICAgIEV2ZW50U2V2ZXJpdHlbXCJJTkZPXCJdID0gXCJJTkZPXCI7XHJcbiAgICBFdmVudFNldmVyaXR5W1wiV0FSTklOR1wiXSA9IFwiV0FSTklOR1wiO1xyXG4gICAgRXZlbnRTZXZlcml0eVtcIkVSUk9SXCJdID0gXCJFUlJPUlwiO1xyXG4gICAgRXZlbnRTZXZlcml0eVtcIkNSSVRJQ0FMXCJdID0gXCJDUklUSUNBTFwiO1xyXG59KShFdmVudFNldmVyaXR5IHx8IChFdmVudFNldmVyaXR5ID0ge30pKTtcclxudmFyIFdpZGdldEV2ZW50VHlwZXM7XHJcbihmdW5jdGlvbiAoV2lkZ2V0RXZlbnRUeXBlcykge1xyXG4gICAgV2lkZ2V0RXZlbnRUeXBlc1tcIldJREdFVF9DTE9TRVwiXSA9IFwiV0lER0VUX0NMT1NFXCI7XHJcbiAgICBXaWRnZXRFdmVudFR5cGVzW1wiV0lER0VUX0NPTkZJR19ET05FXCJdID0gXCJXSURHRVRfQ09ORklHX0RPTkVcIjtcclxuICAgIFdpZGdldEV2ZW50VHlwZXNbXCJXSURHRVRfQ09ORklHX0ZBSUxFRFwiXSA9IFwiV0lER0VUX0NPTkZJR19GQUlMRURcIjtcclxuICAgIFdpZGdldEV2ZW50VHlwZXNbXCJQVVJDSEFTRV9DUkVBVEVEXCJdID0gXCJQVVJDSEFTRV9DUkVBVEVEXCI7XHJcbiAgICBXaWRnZXRFdmVudFR5cGVzW1wiT0ZGUkFNUF9TQUxFX0NSRUFURURcIl0gPSBcIk9GRlJBTVBfU0FMRV9DUkVBVEVEXCI7XHJcbn0pKFdpZGdldEV2ZW50VHlwZXMgfHwgKFdpZGdldEV2ZW50VHlwZXMgPSB7fSkpO1xyXG52YXIgSW50ZXJuYWxFdmVudFR5cGVzO1xyXG4oZnVuY3Rpb24gKEludGVybmFsRXZlbnRUeXBlcykge1xyXG4gICAgSW50ZXJuYWxFdmVudFR5cGVzW1wiV0lER0VUX0NMT1NFX1JFUVVFU1RcIl0gPSBcIldJREdFVF9DTE9TRV9SRVFVRVNUXCI7XHJcbiAgICBJbnRlcm5hbEV2ZW50VHlwZXNbXCJXSURHRVRfQ0xPU0VfUkVRVUVTVF9DQU5DRUxMRURcIl0gPSBcIldJREdFVF9DTE9TRV9SRVFVRVNUX0NBTkNFTExFRFwiO1xyXG4gICAgSW50ZXJuYWxFdmVudFR5cGVzW1wiV0lER0VUX0NMT1NFX1JFUVVFU1RfQ09ORklSTUVEXCJdID0gXCJXSURHRVRfQ0xPU0VfUkVRVUVTVF9DT05GSVJNRURcIjtcclxuICAgIEludGVybmFsRXZlbnRUeXBlc1tcIlJFUVVFU1RfQ1JZUFRPX0FDQ09VTlRcIl0gPSBcIlJFUVVFU1RfQ1JZUFRPX0FDQ09VTlRcIjtcclxuICAgIEludGVybmFsRXZlbnRUeXBlc1tcIlNFTkRfQ1JZUFRPXCJdID0gXCJTRU5EX0NSWVBUT1wiO1xyXG59KShJbnRlcm5hbEV2ZW50VHlwZXMgfHwgKEludGVybmFsRXZlbnRUeXBlcyA9IHt9KSk7XHJcbnZhciBJbnRlcm5hbFNka0V2ZW50VHlwZXM7XHJcbihmdW5jdGlvbiAoSW50ZXJuYWxTZGtFdmVudFR5cGVzKSB7XHJcbiAgICBJbnRlcm5hbFNka0V2ZW50VHlwZXNbXCJSRVFVRVNUX0NSWVBUT19BQ0NPVU5UX1JFU1VMVFwiXSA9IFwiUkVRVUVTVF9DUllQVE9fQUNDT1VOVF9SRVNVTFRcIjtcclxuICAgIEludGVybmFsU2RrRXZlbnRUeXBlc1tcIlNFTkRfQ1JZUFRPX1JFU1VMVFwiXSA9IFwiU0VORF9DUllQVE9fUkVTVUxUXCI7XHJcbn0pKEludGVybmFsU2RrRXZlbnRUeXBlcyB8fCAoSW50ZXJuYWxTZGtFdmVudFR5cGVzID0ge30pKTtcblxuZnVuY3Rpb24gZ2V0UmFuZG9tSW50U3RyaW5nKCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICByZXR1cm4gU3RyaW5nKGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQzMkFycmF5KDEpKVswXSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoX2EpIHtcclxuICAgICAgICAvLyBpZiBgY3J5cHRvYCBpcyBub3Qgc3VwcG9ydGVkLCBmYWxsIGJhY2sgdG8gTWF0aC5yYW5kb21cclxuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tbWFnaWMtbnVtYmVyc1xyXG4gICAgICAgIHJldHVybiBTdHJpbmcoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDAwMDApKTtcclxuICAgIH1cclxufVxyXG52YXIgd2lkZ2V0RGVza3RvcFdpZHRoID0gODk1O1xyXG52YXIgd2lkZ2V0RGVza3RvcEhlaWdodCA9IDU5MDtcclxudmFyIG1pbldpZGdldE1vYmlsZVdpZHRoID0gMzIwO1xyXG52YXIgbWluV2lkZ2V0TW9iaWxlSGVpZ2h0ID0gNjY3O1xyXG5mdW5jdGlvbiBub3JtYWxpemVDb25maWdBbmRMb2dFcnJvcnNPbkludmFsaWRGaWVsZHMoY29uZmlnKSB7XHJcbiAgICB2YXIgZXJyb3JzID0gW107XHJcbiAgICB2YXIgY29uZmlnQ29weSA9IF9fYXNzaWduKHt9LCBjb25maWcpO1xyXG4gICAgaWYgKCFbXHJcbiAgICAgICAgJ2Rlc2t0b3AnLFxyXG4gICAgICAgICdtb2JpbGUnLFxyXG4gICAgICAgICdob3N0ZWQtZGVza3RvcCcsXHJcbiAgICAgICAgJ2hvc3RlZC1tb2JpbGUnLFxyXG4gICAgICAgICdob3N0ZWQtYXV0bycsXHJcbiAgICAgICAgJ2F1dG8nLFxyXG4gICAgICAgICdlbWJlZGRlZC1kZXNrdG9wJyxcclxuICAgICAgICAnZW1iZWRkZWQtbW9iaWxlJyxcclxuICAgIF0uaW5jbHVkZXMoY29uZmlnLnZhcmlhbnQpKSB7XHJcbiAgICAgICAgY29uZmlnQ29weS52YXJpYW50ID0gJ2Rlc2t0b3AnO1xyXG4gICAgICAgIGVycm9ycy5wdXNoKHtcclxuICAgICAgICAgICAgZmllbGROYW1lOiAndmFyaWFudCcsXHJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAnSW52YWxpZCB2YWx1ZSBmb3IgYHZhcmlhbnRgIGNvbmZpZyBmaWVsZCAnLFxyXG4gICAgICAgICAgICBleGFtcGxlVmFsdWU6IFwiJ2Rlc2t0b3AnXCIsXHJcbiAgICAgICAgICAgIHNldmVyaXR5OiBFdmVudFNldmVyaXR5LldBUk5JTkcsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBpZiAoY29uZmlnLnZhcmlhbnQgPT09ICdlbWJlZGRlZC1kZXNrdG9wJyB8fCBjb25maWcudmFyaWFudCA9PT0gJ2VtYmVkZGVkLW1vYmlsZScpIHtcclxuICAgICAgICB2YWxpZGF0ZUNvbnRhaW5lck5vZGUoY29uZmlnLmNvbnRhaW5lck5vZGUsIGNvbmZpZy52YXJpYW50KTtcclxuICAgIH1cclxuICAgIGlmICghWydlbWJlZGRlZC1kZXNrdG9wJywgJ2VtYmVkZGVkLW1vYmlsZSddLmluY2x1ZGVzKGNvbmZpZ0NvcHkudmFyaWFudCkpIHtcclxuICAgICAgICBkZWxldGUgY29uZmlnQ29weS5jb250YWluZXJOb2RlO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBjb25maWcudXNlU2VuZENyeXB0b0NhbGxiYWNrICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIGRlbGV0ZSBjb25maWcudXNlU2VuZENyeXB0b0NhbGxiYWNrO1xyXG4gICAgfVxyXG4gICAgbG9nRXJyb3JzKGVycm9ycyk7XHJcbiAgICByZXR1cm4gY29uZmlnQ29weTtcclxufVxyXG5mdW5jdGlvbiBsb2dFcnJvcnMoZXJyb3JzKSB7XHJcbiAgICBpZiAoIWVycm9ycy5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZTpuby1jb25zb2xlXHJcbiAgICBjb25zb2xlLmdyb3VwKCdDb25maWcgZXJyb3JzJyk7XHJcbiAgICBlcnJvcnMuZm9yRWFjaChmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmdyb3VwKGVycm9yLmZpZWxkTmFtZSk7XHJcbiAgICAgICAgY29uc29sZS5sb2coZXJyb3IuZGVzY3JpcHRpb24pO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiRXhhbXBsZSBleHBlY3RlZCB2YWx1ZTogXCIuY29uY2F0KGVycm9yLmV4YW1wbGVWYWx1ZSkpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiU2V2ZXJpdHk6IFwiLmNvbmNhdChlcnJvci5zZXZlcml0eSkpO1xyXG4gICAgICAgIGNvbnNvbGUuZ3JvdXBFbmQoKTtcclxuICAgIH0pO1xyXG4gICAgY29uc29sZS5ncm91cEVuZCgpO1xyXG4gICAgLy8gdHNsaW50OmVuYWJsZTpuby1jb25zb2xlXHJcbn1cclxuZnVuY3Rpb24gaW5pdEV2ZW50TGlzdGVuZXJzRGljdCgpIHtcclxuICAgIHZhciB3aWRnZXRFdmVudFR5cGVzID0gQXJyYXkuZnJvbShPYmplY3QudmFsdWVzKFdpZGdldEV2ZW50VHlwZXMpKTtcclxuICAgIHZhciBpbnRlcm5hbEV2ZW50VHlwZXMgPSBBcnJheS5mcm9tKE9iamVjdC52YWx1ZXMoSW50ZXJuYWxFdmVudFR5cGVzKSk7XHJcbiAgICByZXR1cm4gX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCB3aWRnZXRFdmVudFR5cGVzLCB0cnVlKSwgaW50ZXJuYWxFdmVudFR5cGVzLCB0cnVlKS5yZWR1Y2UoZnVuY3Rpb24gKGxpc3RlbmVyc0RpY3QsIGV2ZW50VHlwZSkge1xyXG4gICAgICAgIGxpc3RlbmVyc0RpY3RbZXZlbnRUeXBlXSA9IFtdO1xyXG4gICAgICAgIHJldHVybiBsaXN0ZW5lcnNEaWN0O1xyXG4gICAgfSwge30pO1xyXG59XHJcbmZ1bmN0aW9uIGRldGVybWluZVdpZGdldFZhcmlhbnQoY29uZmlnKSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICB2YXIgbWVkaWFRdWVyeSA9ICcobWluLXdpZHRoOiA5MjBweCkgYW5kIChtaW4taGVpZ2h0OiA2MzBweCknO1xyXG4gICAgdmFyIHZhcmlhbnQgPSAoX2EgPSBjb25maWcudmFyaWFudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRvTG9jYWxlTG93ZXJDYXNlKCk7XHJcbiAgICBpZiAodmFyaWFudCA9PT0gJ21vYmlsZScgfHxcclxuICAgICAgICB2YXJpYW50ID09PSAnZGVza3RvcCcgfHxcclxuICAgICAgICB2YXJpYW50ID09PSAnaG9zdGVkLW1vYmlsZScgfHxcclxuICAgICAgICB2YXJpYW50ID09PSAnaG9zdGVkLWRlc2t0b3AnIHx8XHJcbiAgICAgICAgdmFyaWFudCA9PT0gJ2VtYmVkZGVkLWRlc2t0b3AnIHx8XHJcbiAgICAgICAgdmFyaWFudCA9PT0gJ2VtYmVkZGVkLW1vYmlsZScpIHtcclxuICAgICAgICByZXR1cm4gdmFyaWFudDtcclxuICAgIH1cclxuICAgIHZhciBpc0Rlc2t0b3AgPSB3aW5kb3cubWF0Y2hNZWRpYShtZWRpYVF1ZXJ5KS5tYXRjaGVzO1xyXG4gICAgaWYgKHZhcmlhbnQgPT09ICdob3N0ZWQtYXV0bycpIHtcclxuICAgICAgICByZXR1cm4gaXNEZXNrdG9wID8gJ2hvc3RlZC1kZXNrdG9wJyA6ICdob3N0ZWQtbW9iaWxlJztcclxuICAgIH1cclxuICAgIHJldHVybiBpc0Rlc2t0b3AgPyAnZGVza3RvcCcgOiAnbW9iaWxlJztcclxufVxyXG5mdW5jdGlvbiBpc0h0bWxFbGVtZW50KGVsZW1lbnQpIHtcclxuICAgIHJldHVybiB0eXBlb2YgZWxlbWVudC5ibHVyID09PSAnZnVuY3Rpb24nO1xyXG59XHJcbmZ1bmN0aW9uIHZhbGlkYXRlQ29udGFpbmVyTm9kZShjb250YWluZXJOb2RlLCB2YXJpYW50KSB7XHJcbiAgICBpZiAoIWRvY3VtZW50LmJvZHkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIDxib2R5PiBlbGVtZW50LlwiKTtcclxuICAgIH1cclxuICAgIGlmICghKGNvbnRhaW5lck5vZGUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbnRhaW5lciBub2RlIGhhcyB0byBiZSBhIHByb3BlciBIVE1MIGVsZW1lbnQuJyk7XHJcbiAgICB9XHJcbiAgICBpZiAoIWRvY3VtZW50LmJvZHkuY29udGFpbnMoY29udGFpbmVyTm9kZSkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbnRhaW5lciBub2RlIG11c3QgYmUgYXR0YWNoZWQgdG8gdGhlIGRvY3VtZW50LicpO1xyXG4gICAgfVxyXG4gICAgdmFyIF9hID0gY29udGFpbmVyTm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgd2lkdGggPSBfYS53aWR0aCwgaGVpZ2h0ID0gX2EuaGVpZ2h0O1xyXG4gICAgaWYgKHZhcmlhbnQgPT09ICdlbWJlZGRlZC1kZXNrdG9wJykge1xyXG4gICAgICAgIGlmICh3aWR0aCArIDEgPCB3aWRnZXREZXNrdG9wV2lkdGgpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29udGFpbmVyIG5vZGUgbXVzdCBiZSBhdCBsZWFzdCBcIi5jb25jYXQod2lkZ2V0RGVza3RvcFdpZHRoLCBcInB4IHdpZGUuXCIpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGhlaWdodCArIDEgPCB3aWRnZXREZXNrdG9wSGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbnRhaW5lciBub2RlIG11c3QgYmUgYXQgbGVhc3QgXCIuY29uY2F0KHdpZGdldERlc2t0b3BIZWlnaHQsIFwicHggdGFsbC5cIikpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHZhcmlhbnQgPT09ICdlbWJlZGRlZC1tb2JpbGUnKSB7XHJcbiAgICAgICAgaWYgKHdpZHRoICsgMSA8IG1pbldpZGdldE1vYmlsZVdpZHRoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbnRhaW5lciBub2RlIG11c3QgYmUgYXQgbGVhc3QgXCIuY29uY2F0KG1pbldpZGdldE1vYmlsZVdpZHRoLCBcInB4IHdpZGUuXCIpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGhlaWdodCArIDEgPCBtaW5XaWRnZXRNb2JpbGVIZWlnaHQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29udGFpbmVyIG5vZGUgbXVzdCBiZSBhdCBsZWFzdCBcIi5jb25jYXQobWluV2lkZ2V0TW9iaWxlSGVpZ2h0LCBcInB4IHRhbGwuXCIpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuZnVuY3Rpb24gZ2V0QmFzZVVybChjb25maWcpIHtcclxuICAgIHJldHVybiBuZXcgVVJMKGNvbmZpZy51cmwgfHwgYmFzZVdpZGdldFVybCk7XHJcbn1cclxuZnVuY3Rpb24gaW5pdFdpZGdldElmcmFtZVVybChjb25maWcpIHtcclxuICAgIHZhciBiYXNlVXJsID0gZ2V0QmFzZVVybChjb25maWcpO1xyXG4gICAgdmFyIGhvc3RVcmwgPSB3aW5kb3cubG9jYXRpb24ub3JpZ2luO1xyXG4gICAgY29uZmlnLmNvbnRhaW5lck5vZGU7IGNvbmZpZy51cmw7IHZhciBjb25maWdXaXRob3V0SWZyYW1lVXJsID0gX19yZXN0KGNvbmZpZywgW1wiY29udGFpbmVyTm9kZVwiLCBcInVybFwiXSk7XHJcbiAgICB2YXIgcHJlcGFyZWRDb25maWcgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgY29uZmlnV2l0aG91dElmcmFtZVVybCksIHsgaG9zdFVybDogaG9zdFVybCB9KTtcclxuICAgIE9iamVjdC5lbnRyaWVzKHByZXBhcmVkQ29uZmlnKS5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgIHZhciBrZXkgPSBfYVswXSwgdmFsdWUgPSBfYVsxXTtcclxuICAgICAgICBpZiAodmFsdWUpIHtcclxuICAgICAgICAgICAgYmFzZVVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGtleSwgQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5qb2luKCcsJykgOiB2YWx1ZS50b1N0cmluZygpKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBiYXNlVXJsLnRvU3RyaW5nKCk7XHJcbn1cclxuZnVuY3Rpb24gaGlkZVdlYnNpdGVCZWxvdyhwYXJlbnQsIGNvbnRhaW5lcldpZHRoKSB7XHJcbiAgICB2YXIgYmFja2dyb3VuZFdlYnNpdGVIaWRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgYmFja2dyb3VuZFdlYnNpdGVIaWRlci5jbGFzc0xpc3QuYWRkKCdiYWNrZ3JvdW5kLWhpZGVyJyk7XHJcbiAgICBpZiAoY29udGFpbmVyV2lkdGgpIHtcclxuICAgICAgICBiYWNrZ3JvdW5kV2Vic2l0ZUhpZGVyLnN0eWxlLm1heFdpZHRoID0gXCJcIi5jb25jYXQoY29udGFpbmVyV2lkdGgsIFwicHhcIik7XHJcbiAgICB9XHJcbiAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoYmFja2dyb3VuZFdlYnNpdGVIaWRlcik7XHJcbn1cclxuZnVuY3Rpb24gaW5pdERPTU5vZGVXaXRoT3ZlcmxheSh1cmwsIGRpc3BhdGNoLCBjb25maWcpIHtcclxuICAgIHZhciBib2R5ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYm9keScpO1xyXG4gICAgdmFyIHNoYWRvd0hvc3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgIHNoYWRvd0hvc3Quc3R5bGUud2lkdGggPSAnMTAwJSc7XHJcbiAgICBzaGFkb3dIb3N0LnN0eWxlLmhlaWdodCA9ICcxMDAlJztcclxuICAgIHZhciBzaGFkb3cgPSBzaGFkb3dIb3N0LmF0dGFjaFNoYWRvdyh7IG1vZGU6ICdvcGVuJyB9KTtcclxuICAgIHNoYWRvdy5hcHBlbmRDaGlsZChnZXRTdHlsZXNGb3JTaGFkb3dEb20oY29uZmlnLnZhcmlhbnQpKTtcclxuICAgIHZhciBpZnJhbWUgPSBwcmVwYXJlSWZyYW1lTm9kZSh1cmwsIGNvbmZpZy52YXJpYW50KTtcclxuICAgIHZhciBvdmVybGF5ID0gcHJlcGFyZU92ZXJsYXlOb2RlKGlmcmFtZSwgZGlzcGF0Y2gpO1xyXG4gICAgb3ZlcmxheS5hcHBlbmRDaGlsZChpZnJhbWUpO1xyXG4gICAgc2hhZG93LmFwcGVuZENoaWxkKG92ZXJsYXkpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBib2R5OiBib2R5LFxyXG4gICAgICAgIGlmcmFtZTogaWZyYW1lLFxyXG4gICAgICAgIG92ZXJsYXk6IG92ZXJsYXksXHJcbiAgICAgICAgc2hhZG93OiBzaGFkb3csXHJcbiAgICAgICAgc2hhZG93SG9zdDogc2hhZG93SG9zdCxcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gaW5pdERPTU5vZGVXaXRob3V0T3ZlcmxheSh1cmwsIF9kaXNwYXRjaCwgY29uZmlnKSB7XHJcbiAgICB2YXIgYm9keSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2JvZHknKTtcclxuICAgIHZhciBzaGFkb3dIb3N0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICBzaGFkb3dIb3N0LnN0eWxlLndpZHRoID0gJzEwMCUnO1xyXG4gICAgc2hhZG93SG9zdC5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XHJcbiAgICB2YXIgc2hhZG93ID0gc2hhZG93SG9zdC5hdHRhY2hTaGFkb3coeyBtb2RlOiAnb3BlbicgfSk7XHJcbiAgICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICBjb250YWluZXIuY2xhc3NMaXN0LmFkZCgnZW1iZWRkZWQtY29udGFpbmVyJyk7XHJcbiAgICBzaGFkb3cuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcclxuICAgIHZhciBsb2FkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgIGxvYWRlci5jbGFzc0xpc3QuYWRkKCdsb2FkZXItY29udGFpbmVyJyk7XHJcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZTptYXgtbGluZS1sZW5ndGhcclxuICAgIGxvYWRlci5pbm5lckhUTUwgPSBcIlxcbiAgICA8c3ZnIHdpZHRoPVxcXCI5MlxcXCIgaGVpZ2h0PVxcXCI2MFxcXCIgdmlld0JveD1cXFwiMCAwIDUxIDMyXFxcIiBmaWxsPVxcXCJub25lXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIGNsYXNzPVxcXCJsb2FkZXJcXFwiPlxcbiAgICAgIDxwYXRoIGQ9XFxcIk0xNi4yMjMyIDE4LjgzMDlMMjIuMjgyIDI0LjkxMkMyMi43OTUzIDI1LjQyNzIgMjIuNzk0OCAyNi4yNjQ3IDIyLjI4MSAyNi43NzkyTDE3LjY1MSAzMS40MTU4QzE2Ljg2MTkgMzIuMTk0NyAxNS41NzE5IDMyLjE5NDcgMTQuNzgyOCAzMS40MTU4TDAuNTkxODEyIDE3LjQwOTNDLTAuMTk3MjcxIDE2LjYzMDUgLTAuMTk3MjcxIDE1LjM1NzEgMC41OTE4MTIgMTQuNTc4M0wxNC43ODI4IDAuNTg0MTIyQzE1LjU3MTkgLTAuMTk0NzA3IDE2Ljg2MTkgLTAuMTk0NzA3IDE3LjY1MSAwLjU4NDEyMkwyMi4yODEgNS4yMjA3OEMyMi43OTQ4IDUuNzM1MzUgMjIuNzk1MyA2LjU3MjgxIDIyLjI4MiA3LjA4Nzk1TDE2LjIyMzIgMTMuMTY5MUMxNC42NDUgMTQuNzI2NyAxNC42NDUgMTcuMjczMyAxNi4yMjMyIDE4LjgzMDlaXFxcIiBmaWxsPVxcXCIjMjFCRjczXFxcIj48L3BhdGg+XFxuICAgICAgPHBhdGggZD1cXFwiTTM0LjQ0MzMgMTguODMwOUwyOC4zODQ1IDI0LjkxMkMyNy44NzEyIDI1LjQyNzIgMjcuODcxNyAyNi4yNjQ3IDI4LjM4NTUgMjYuNzc5MkwzMy4wMTU1IDMxLjQxNThDMzMuODA0NiAzMi4xOTQ3IDM1LjA5NDYgMzIuMTk0NyAzNS44ODM3IDMxLjQxNThMNTAuMDc0NyAxNy40MDkzQzUwLjg2MzggMTYuNjMwNSA1MC44NjM4IDE1LjM1NzEgNTAuMDc0NyAxNC41NzgzTDM1Ljg4MzcgMC41ODQxMjJDMzUuMDk0NiAtMC4xOTQ3MDcgMzMuODA0NiAtMC4xOTQ3MDcgMzMuMDE1NSAwLjU4NDEyMkwyOC4zODU1IDUuMjIwNzhDMjcuODcxNyA1LjczNTM1IDI3Ljg3MTIgNi41NzI4MSAyOC4zODQ1IDcuMDg3OTVMMzQuNDQzMyAxMy4xNjkxQzM2LjAyMTUgMTQuNzI2NyAzNi4wMjE1IDE3LjI3MzMgMzQuNDQzMyAxOC44MzA5WlxcXCIgZmlsbD1cXFwiIzBBNkU1Q1xcXCI+PC9wYXRoPlxcbiAgICAgIDxwYXRoIGQ9XFxcIk0xNy44MTI4IDE3LjE1N0MxNy4xNzM3IDE2LjUxOCAxNy4xNzM3IDE1LjQ4MiAxNy44MTI4IDE0Ljg0M0wyNC4xNzY1IDguNDc5MjZDMjQuODE1NSA3Ljg0MDI1IDI1Ljg1MTUgNy44NDAyNSAyNi40OTA1IDguNDc5MjZMMzIuODU0MiAxNC44NDNDMzMuNDkzMiAxNS40ODIgMzMuNDkzMiAxNi41MTggMzIuODU0MiAxNy4xNTdMMjYuNDkwNSAyMy41MjA3QzI1Ljg1MTUgMjQuMTU5OCAyNC44MTU1IDI0LjE1OTggMjQuMTc2NSAyMy41MjA3TDE3LjgxMjggMTcuMTU3WlxcXCIgZmlsbD1cXFwiIzIxQkY3M1xcXCI+PC9wYXRoPlxcbiAgICA8L3N2Zz5cIjtcclxuICAgIC8vIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoXHJcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQobG9hZGVyKTtcclxuICAgIHNoYWRvdy5hcHBlbmRDaGlsZChnZXRTdHlsZXNGb3JTaGFkb3dEb20oY29uZmlnLnZhcmlhbnQpKTtcclxuICAgIHZhciBpZnJhbWUgPSBwcmVwYXJlSWZyYW1lTm9kZSh1cmwsIGNvbmZpZy52YXJpYW50LCBjb25maWcuY29udGFpbmVyTm9kZSk7XHJcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgYm9keTogYm9keSxcclxuICAgICAgICBpZnJhbWU6IGlmcmFtZSxcclxuICAgICAgICBvdmVybGF5OiBudWxsLFxyXG4gICAgICAgIHNoYWRvdzogc2hhZG93LFxyXG4gICAgICAgIHNoYWRvd0hvc3Q6IHNoYWRvd0hvc3QsXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGltcG9ydEZvbnRzKCkge1xyXG4gICAgaWYgKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLXJhbXAtZm9udF0nKSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHZhciBmb250ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGluaycpO1xyXG4gICAgZm9udC5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCAnaHR0cHM6Ly9mb250cy5nb29nbGVhcGlzLmNvbS9jc3M/ZmFtaWx5PVBvcHBpbnM6MjAwLDQwMCw1MDAsNjAwLDcwMCZkaXNwbGF5PXN3YXAmc3Vic2V0PWxhdGluLWV4dCcpO1xyXG4gICAgZm9udC5zZXRBdHRyaWJ1dGUoJ3JlbCcsICdzdHlsZXNoZWV0Jyk7XHJcbiAgICBmb250LnNldEF0dHJpYnV0ZSgnZGF0YS1yYW1wLWZvbnQnLCAnJyk7XHJcbiAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKGZvbnQpO1xyXG59XHJcbmZ1bmN0aW9uIHByZXBhcmVJZnJhbWVOb2RlKHVybCwgdmFyaWFudCwgY29udGFpbmVyTm9kZSkge1xyXG4gICAgdmFyIGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xyXG4gICAgaWZyYW1lLnNldEF0dHJpYnV0ZSgnc3JjJywgdXJsKTtcclxuICAgIGlmIChjb250YWluZXJOb2RlKSB7XHJcbiAgICAgICAgaWZyYW1lLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCB2YXJpYW50ID09PSAnZGVza3RvcCcgfHwgdmFyaWFudCA9PT0gJ2VtYmVkZGVkLWRlc2t0b3AnXHJcbiAgICAgICAgICAgID8gd2lkZ2V0RGVza3RvcFdpZHRoLnRvU3RyaW5nKClcclxuICAgICAgICAgICAgOiBjb250YWluZXJOb2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgIGlmcmFtZS5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHZhcmlhbnQgPT09ICdkZXNrdG9wJyB8fCB2YXJpYW50ID09PSAnZW1iZWRkZWQtZGVza3RvcCdcclxuICAgICAgICAgICAgPyB3aWRnZXREZXNrdG9wSGVpZ2h0LnRvU3RyaW5nKClcclxuICAgICAgICAgICAgOiBjb250YWluZXJOb2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodC50b1N0cmluZygpKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGlmcmFtZS5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgdmFyaWFudCA9PT0gJ2Rlc2t0b3AnIHx8IHZhcmlhbnQgPT09ICdlbWJlZGRlZC1kZXNrdG9wJ1xyXG4gICAgICAgICAgICA/IHdpZGdldERlc2t0b3BXaWR0aC50b1N0cmluZygpXHJcbiAgICAgICAgICAgIDogd2luZG93LmlubmVyV2lkdGgudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgaWZyYW1lLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgdmFyaWFudCA9PT0gJ2Rlc2t0b3AnIHx8IHZhcmlhbnQgPT09ICdlbWJlZGRlZC1kZXNrdG9wJ1xyXG4gICAgICAgICAgICA/IHdpZGdldERlc2t0b3BIZWlnaHQudG9TdHJpbmcoKVxyXG4gICAgICAgICAgICA6IHdpbmRvdy5pbm5lckhlaWdodC50b1N0cmluZygpKTtcclxuICAgIH1cclxuICAgIGlmcmFtZS5zZXRBdHRyaWJ1dGUoJ2FsbG93JywgJ3BheW1lbnQ7IG1pY3JvcGhvbmU7IGNhbWVyYTsgY2xpcGJvYXJkLXJlYWQ7IGNsaXBib2FyZC13cml0ZScpO1xyXG4gICAgaWZyYW1lLmNsYXNzTGlzdC5hZGQoJ2lmcmFtZScpO1xyXG4gICAgcmV0dXJuIGlmcmFtZTtcclxufVxyXG5mdW5jdGlvbiBwcmVwYXJlT3ZlcmxheU5vZGUoaWZyYW1lLCBkaXNwYXRjaCkge1xyXG4gICAgdmFyIG92ZXJsYXkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgIG92ZXJsYXkuY2xhc3NMaXN0LmFkZCgnb3ZlcmxheScpO1xyXG4gICAgdmFyIGxvYWRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgbG9hZGVyLmNsYXNzTGlzdC5hZGQoJ2xvYWRlci1jb250YWluZXInKTtcclxuICAgIC8vIHRzbGludDpkaXNhYmxlOm1heC1saW5lLWxlbmd0aFxyXG4gICAgbG9hZGVyLmlubmVySFRNTCA9IFwiXFxuICAgIDxzdmcgd2lkdGg9XFxcIjkyXFxcIiBoZWlnaHQ9XFxcIjYwXFxcIiB2aWV3Qm94PVxcXCIwIDAgNTEgMzJcXFwiIGZpbGw9XFxcIm5vbmVcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIgY2xhc3M9XFxcImxvYWRlclxcXCI+XFxuICAgICAgPHBhdGggZD1cXFwiTTE2LjIyMzIgMTguODMwOUwyMi4yODIgMjQuOTEyQzIyLjc5NTMgMjUuNDI3MiAyMi43OTQ4IDI2LjI2NDcgMjIuMjgxIDI2Ljc3OTJMMTcuNjUxIDMxLjQxNThDMTYuODYxOSAzMi4xOTQ3IDE1LjU3MTkgMzIuMTk0NyAxNC43ODI4IDMxLjQxNThMMC41OTE4MTIgMTcuNDA5M0MtMC4xOTcyNzEgMTYuNjMwNSAtMC4xOTcyNzEgMTUuMzU3MSAwLjU5MTgxMiAxNC41NzgzTDE0Ljc4MjggMC41ODQxMjJDMTUuNTcxOSAtMC4xOTQ3MDcgMTYuODYxOSAtMC4xOTQ3MDcgMTcuNjUxIDAuNTg0MTIyTDIyLjI4MSA1LjIyMDc4QzIyLjc5NDggNS43MzUzNSAyMi43OTUzIDYuNTcyODEgMjIuMjgyIDcuMDg3OTVMMTYuMjIzMiAxMy4xNjkxQzE0LjY0NSAxNC43MjY3IDE0LjY0NSAxNy4yNzMzIDE2LjIyMzIgMTguODMwOVpcXFwiIGZpbGw9XFxcIiMyMUJGNzNcXFwiPjwvcGF0aD5cXG4gICAgICA8cGF0aCBkPVxcXCJNMzQuNDQzMyAxOC44MzA5TDI4LjM4NDUgMjQuOTEyQzI3Ljg3MTIgMjUuNDI3MiAyNy44NzE3IDI2LjI2NDcgMjguMzg1NSAyNi43NzkyTDMzLjAxNTUgMzEuNDE1OEMzMy44MDQ2IDMyLjE5NDcgMzUuMDk0NiAzMi4xOTQ3IDM1Ljg4MzcgMzEuNDE1OEw1MC4wNzQ3IDE3LjQwOTNDNTAuODYzOCAxNi42MzA1IDUwLjg2MzggMTUuMzU3MSA1MC4wNzQ3IDE0LjU3ODNMMzUuODgzNyAwLjU4NDEyMkMzNS4wOTQ2IC0wLjE5NDcwNyAzMy44MDQ2IC0wLjE5NDcwNyAzMy4wMTU1IDAuNTg0MTIyTDI4LjM4NTUgNS4yMjA3OEMyNy44NzE3IDUuNzM1MzUgMjcuODcxMiA2LjU3MjgxIDI4LjM4NDUgNy4wODc5NUwzNC40NDMzIDEzLjE2OTFDMzYuMDIxNSAxNC43MjY3IDM2LjAyMTUgMTcuMjczMyAzNC40NDMzIDE4LjgzMDlaXFxcIiBmaWxsPVxcXCIjMEE2RTVDXFxcIj48L3BhdGg+XFxuICAgICAgPHBhdGggZD1cXFwiTTE3LjgxMjggMTcuMTU3QzE3LjE3MzcgMTYuNTE4IDE3LjE3MzcgMTUuNDgyIDE3LjgxMjggMTQuODQzTDI0LjE3NjUgOC40NzkyNkMyNC44MTU1IDcuODQwMjUgMjUuODUxNSA3Ljg0MDI1IDI2LjQ5MDUgOC40NzkyNkwzMi44NTQyIDE0Ljg0M0MzMy40OTMyIDE1LjQ4MiAzMy40OTMyIDE2LjUxOCAzMi44NTQyIDE3LjE1N0wyNi40OTA1IDIzLjUyMDdDMjUuODUxNSAyNC4xNTk4IDI0LjgxNTUgMjQuMTU5OCAyNC4xNzY1IDIzLjUyMDdMMTcuODEyOCAxNy4xNTdaXFxcIiBmaWxsPVxcXCIjMjFCRjczXFxcIj48L3BhdGg+XFxuICAgIDwvc3ZnPlwiO1xyXG4gICAgLy8gdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGhcclxuICAgIG92ZXJsYXkuYXBwZW5kQ2hpbGQobG9hZGVyKTtcclxuICAgIG92ZXJsYXkuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICBpZiAoZXZlbnQudGFyZ2V0ICE9PSBpZnJhbWUgJiYgIW92ZXJsYXkucXVlcnlTZWxlY3RvckFsbCgnLmNsb3NlLW1vZGFsJykubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGRpc3BhdGNoKHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IEludGVybmFsRXZlbnRUeXBlcy5XSURHRVRfQ0xPU0VfUkVRVUVTVCxcclxuICAgICAgICAgICAgICAgIHBheWxvYWQ6IG51bGwsXHJcbiAgICAgICAgICAgICAgICBpbnRlcm5hbDogdHJ1ZSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gb3ZlcmxheTtcclxufVxyXG5mdW5jdGlvbiBhcmVVcmxzRXF1YWwodXJsMCwgdXJsMSkge1xyXG4gICAgcmV0dXJuIG5ldyBVUkwodXJsMCkudG9TdHJpbmcoKSA9PT0gbmV3IFVSTCh1cmwxKS50b1N0cmluZygpO1xyXG59XHJcbmZ1bmN0aW9uIGlzQ2xvc2VNb2RhbEFscmVhZHlPcGVuKGNvbnRhaW5lck5vZGUpIHtcclxuICAgIHJldHVybiBjb250YWluZXJOb2RlLnF1ZXJ5U2VsZWN0b3JBbGwoJy5jbG9zZS1tb2RhbCcpLmxlbmd0aCAhPT0gMDtcclxufVxyXG5mdW5jdGlvbiBwcmVwYXJlQ2xvc2VNb2RhbE5vZGUoZGlzcGF0Y2gpIHtcclxuICAgIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgIGNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdjbG9zZS1tb2RhbCcpO1xyXG4gICAgdmFyIHRleHRFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgdGV4dEVsLmNsYXNzTGlzdC5hZGQoJ2Nsb3NlLW1vZGFsX190ZXh0Jyk7XHJcbiAgICB0ZXh0RWwudGV4dENvbnRlbnQgPSAnQXJlIHlvdSBzdXJlIHlvdSB3YW50IHRvIGV4aXQgUmFtcCBhbmQgYWJhbmRvbiB0aGUgdHJhbnNhY3Rpb24/JztcclxuICAgIHZhciBidXR0b25Db250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgIGJ1dHRvbkNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdjbG9zZS1tb2RhbF9fYnV0dG9uLWNvbnRhaW5lcicpO1xyXG4gICAgdmFyIGNhbmNlbEJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xyXG4gICAgY2FuY2VsQnV0dG9uLnNldEF0dHJpYnV0ZSgndHlwZScsICdidXR0b24nKTtcclxuICAgIGNhbmNlbEJ1dHRvbi5jbGFzc0xpc3QuYWRkKCdjbG9zZS1tb2RhbF9fYnV0dG9uJyk7XHJcbiAgICBjYW5jZWxCdXR0b24uY2xhc3NMaXN0LmFkZCgnY2xvc2UtbW9kYWxfX2J1dHRvbi0tY2FuY2VsJyk7XHJcbiAgICBjYW5jZWxCdXR0b24udGV4dENvbnRlbnQgPSAnQ2FuY2VsJztcclxuICAgIGNhbmNlbEJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgIGRpc3BhdGNoKHtcclxuICAgICAgICAgICAgdHlwZTogSW50ZXJuYWxFdmVudFR5cGVzLldJREdFVF9DTE9TRV9SRVFVRVNUX0NBTkNFTExFRCxcclxuICAgICAgICAgICAgcGF5bG9hZDogbnVsbCxcclxuICAgICAgICAgICAgaW50ZXJuYWw6IHRydWUsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuICAgIHZhciBleGl0QnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XHJcbiAgICBleGl0QnV0dG9uLnNldEF0dHJpYnV0ZSgndHlwZScsICdidXR0b24nKTtcclxuICAgIGV4aXRCdXR0b24uY2xhc3NMaXN0LmFkZCgnY2xvc2UtbW9kYWxfX2J1dHRvbicpO1xyXG4gICAgZXhpdEJ1dHRvbi5jbGFzc0xpc3QuYWRkKCdjbG9zZS1tb2RhbF9fYnV0dG9uLS1leGl0Jyk7XHJcbiAgICBleGl0QnV0dG9uLnRleHRDb250ZW50ID0gJ0V4aXQnO1xyXG4gICAgZXhpdEJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgIGRpc3BhdGNoKHtcclxuICAgICAgICAgICAgdHlwZTogSW50ZXJuYWxFdmVudFR5cGVzLldJREdFVF9DTE9TRV9SRVFVRVNUX0NPTkZJUk1FRCxcclxuICAgICAgICAgICAgcGF5bG9hZDogbnVsbCxcclxuICAgICAgICAgICAgaW50ZXJuYWw6IHRydWUsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuICAgIGJ1dHRvbkNvbnRhaW5lci5hcHBlbmRDaGlsZChjYW5jZWxCdXR0b24pO1xyXG4gICAgYnV0dG9uQ29udGFpbmVyLmFwcGVuZENoaWxkKGV4aXRCdXR0b24pO1xyXG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHRleHRFbCk7XHJcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoYnV0dG9uQ29udGFpbmVyKTtcclxuICAgIHJldHVybiBjb250YWluZXI7XHJcbn1cclxuZnVuY3Rpb24gZ2V0U3R5bGVzRm9yU2hhZG93RG9tKHZhcmlhbnQpIHtcclxuICAgIHZhciBzdHlsZXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xyXG4gICAgdmFyIGlzTW9iaWxlID0gdmFyaWFudCA9PT0gJ21vYmlsZScgfHxcclxuICAgICAgICB2YXJpYW50ID09PSAnaG9zdGVkLW1vYmlsZScgfHxcclxuICAgICAgICB2YXJpYW50ID09PSAnZW1iZWRkZWQtbW9iaWxlJyB8fFxyXG4gICAgICAgIHZhcmlhbnQgPT09ICd3ZWJ2aWV3LW1vYmlsZSc7XHJcbiAgICB2YXIgaXNFbWJlZGRlZCA9IHZhcmlhbnQgPT09ICdlbWJlZGRlZC1tb2JpbGUnIHx8IHZhcmlhbnQgPT09ICdlbWJlZGRlZC1kZXNrdG9wJztcclxuICAgIHN0eWxlcy50ZXh0Q29udGVudCA9IFwiXFxuXFxuICAgIC5iYWNrZ3JvdW5kLWhpZGVyIHtcXG4gICAgICBjb250ZW50OiAnJztcXG4gICAgICBoZWlnaHQ6IDMwdmg7XFxuICAgICAgd2lkdGg6IDEwMHZ3O1xcbiAgICAgIHBvc2l0aW9uOiBmaXhlZDtcXG4gICAgICBib3R0b206IDA7XFxuICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDUwJSk7XFxuICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2Y1ZjhmYjtcXG4gICAgICB6LWluZGV4OiA5OTk7XFxuICAgIH1cXG5cXG4gICAgLm92ZXJsYXkge1xcbiAgICAgIHBvc2l0aW9uOiBmaXhlZDtcXG4gICAgICB6LWluZGV4OiAxMDAwO1xcbiAgICAgIHdpZHRoOiAxMDB2dztcXG4gICAgICBoZWlnaHQ6IFwiLmNvbmNhdChpc01vYmlsZSA/ICcxMDAlOycgOiAnMTAwdmg7JywgXCJcXG4gICAgICB0b3A6IDA7XFxuICAgICAgbGVmdDogMDtcXG4gICAgICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMTY2LCAxNzQsIDE4NSwgMC43KTtcXG4gICAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICAgIGZsZXgtZmxvdzogcm93IG5vd3JhcDtcXG4gICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gICAgICBcIikuY29uY2F0KGlzTW9iaWxlID8gJ2FsaWduLWl0ZW1zOiBmbGV4LXN0YXJ0OycgOiAnYWxpZ24taXRlbXM6IGNlbnRlcjsnLCBcIlxcbiAgICB9XFxuXFxuICAgIC5lbWJlZGRlZC1jb250YWluZXIge1xcbiAgICAgIHotaW5kZXg6IDEwMDA7XFxuICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICAgIHdpZHRoOiAxMDAlO1xcbiAgICAgIGhlaWdodDogMTAwJTtcXG4gICAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICAgIGZsZXgtZmxvdzogcm93IG5vd3JhcDtcXG4gICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gICAgICBcIikuY29uY2F0KGlzTW9iaWxlID8gJ2FsaWduLWl0ZW1zOiBmbGV4LXN0YXJ0OycgOiAnYWxpZ24taXRlbXM6IGNlbnRlcjsnLCBcIlxcbiAgICAgIG1pbi13aWR0aDogXCIpLmNvbmNhdChpc01vYmlsZSA/IG1pbldpZGdldE1vYmlsZVdpZHRoIDogd2lkZ2V0RGVza3RvcFdpZHRoLCBcInB4O1xcbiAgICAgIG1pbi1oZWlnaHQ6IFwiKS5jb25jYXQoaXNNb2JpbGUgPyBtaW5XaWRnZXRNb2JpbGVIZWlnaHQgOiB3aWRnZXREZXNrdG9wSGVpZ2h0LCBcInB4O1xcbiAgICB9XFxuXFxuICAgIC5sb2FkZXItY29udGFpbmVyIHtcXG4gICAgICBhbGlnbi1zZWxmOiBjZW50ZXI7XFxuICAgIH1cXG5cXG4gICAgLmxvYWRlciB7XFxuICAgICAgdHJhbnNmb3JtLW9yaWdpbjogY2VudGVyO1xcbiAgICAgIGFuaW1hdGlvbjogbG9nb0FuaW1hdGlvbiA0cyBsaW5lYXIgaW5maW5pdGU7XFxuICAgICAgd2lkdGg6IDEwMHB4O1xcbiAgICAgIGhlaWdodDogYXV0bztcXG4gICAgICBhbGlnbi1zZWxmOiBjZW50ZXI7XFxuICAgIH1cXG5cXG4gICAgLmxvYWRlciBwYXRoOm50aC1jaGlsZCgzKSB7XFxuICAgICAgdHJhbnNmb3JtLW9yaWdpbjogY2VudGVyO1xcbiAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgfVxcblxcbiAgICAubG9hZGVyIHBhdGg6bnRoLWNoaWxkKDEpIHtcXG4gICAgICB0cmFuc2Zvcm0tb3JpZ2luOiBjZW50ZXI7XFxuICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICAgIGFuaW1hdGlvbjogYm94MUFuaW1hdGlvbiA0cyBsaW5lYXIgaW5maW5pdGU7XFxuICAgICAgdHJhbnNmb3JtOiBzY2FsZSgwLjQpIHRyYW5zbGF0ZVgoNnB4KTtcXG4gICAgfVxcblxcbiAgICAubG9hZGVyIHBhdGg6bnRoLWNoaWxkKDIpIHtcXG4gICAgICB0cmFuc2Zvcm0tb3JpZ2luOiBjZW50ZXI7XFxuICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICAgIGFuaW1hdGlvbjogYm94NEFuaW1hdGlvbiA0cyBsaW5lYXIgaW5maW5pdGU7XFxuICAgICAgdHJhbnNmb3JtOiBzY2FsZSgwLjQpIHRyYW5zbGF0ZVgoLTZweCk7XFxuICAgIH1cXG5cXG4gICAgQGtleWZyYW1lcyBsb2dvQW5pbWF0aW9uIHtcXG4gICAgICAxMCUge1xcbiAgICAgICAgdHJhbnNmb3JtOiByb3RhdGUoMTgwZGVnKTtcXG4gICAgICB9XFxuICAgICAgMzAle1xcbiAgICAgICAgdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTtcXG4gICAgICB9XFxuICAgICAgNzAlIHtcXG4gICAgICAgIHRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7XFxuICAgICAgfVxcbiAgICAgIDkwJSB7XFxuICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSg1MjBkZWcpO1xcbiAgICAgIH1cXG4gICAgICAxMDAlIHtcXG4gICAgICAgIHRyYW5zZm9ybTogcm90YXRlKDcyMGRlZyk7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIEBrZXlmcmFtZXMgYm94MUFuaW1hdGlvbiB7XFxuICAgICAgMCUsIDEwJSB7XFxuICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDAuNCkgdHJhbnNsYXRlWCg2cHgpO1xcbiAgICAgIH1cXG4gICAgICAzMCUsIDcwJSB7XFxuICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDEpIHRyYW5zbGF0ZVgoMCk7XFxuICAgICAgfVxcbiAgICAgIDkwJSB7XFxuICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDAuNCkgdHJhbnNsYXRlWCg2cHgpO1xcbiAgICAgIH1cXG4gICAgfVxcblxcblxcbiAgICBAa2V5ZnJhbWVzIGJveDRBbmltYXRpb24ge1xcbiAgICAgIDAlLCAxMCUge1xcbiAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgwLjQpIHRyYW5zbGF0ZVgoLTZweCk7XFxuICAgICAgfVxcbiAgICAgIDMwJSwgNzAlIHtcXG4gICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMSkgdHJhbnNsYXRlWCgwKTtcXG4gICAgICB9XFxuICAgICAgOTAlIHtcXG4gICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMC40KSB0cmFuc2xhdGVYKC02cHgpO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICAuaWZyYW1lIHtcXG4gICAgICBib3JkZXI6IG5vbmU7XFxuICAgICAgdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAgICAgdmlzaWJpbGl0eTogaGlkZGVuO1xcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgICBjb2xvci1zY2hlbWU6IG9ubHkgbGlnaHQ7XFxuICAgIH1cXG5cXG4gICAgLmlmcmFtZS52aXNpYmxlIHtcXG4gICAgICB2aXNpYmlsaXR5OiB2aXNpYmxlO1xcbiAgICAgIFwiKS5jb25jYXQoIWlzRW1iZWRkZWQgJiYgaXNNb2JpbGVcclxuICAgICAgICA/IFwiXFxuICAgICAgICB3aWR0aDogMTAwdnc7XFxuICAgICAgICBoZWlnaHQ6IDEwMCU7XFxuICAgICAgXCJcclxuICAgICAgICA6ICcnLCBcIlxcbiAgICB9XFxuXFxuICAgIC5jbG9zZS1tb2RhbCB7XFxuICAgICAgZm9udC1mYW1pbHk6ICdQb3BwaW5zJywgc2Fucy1zZXJpZjtcXG4gICAgICB3aWR0aDogNjc4cHg7XFxuICAgICAgaGVpZ2h0OiAyNzZweDtcXG4gICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgICAgbGVmdDogNTAlO1xcbiAgICAgIHRvcDogNTAlO1xcbiAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKC01MCUsIC01MCUpO1xcbiAgICAgIHotaW5kZXg6IDk5OTk7XFxuICAgICAgYm94LXNoYWRvdzogMHB4IDU0cHggMjAwcHggcmdiYSgzNiwgMzcsIDU3LCAwLjIpO1xcbiAgICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgICAgZmxleC1mbG93OiBjb2x1bW4gbm93cmFwO1xcbiAgICAgIGp1c3RpZnktY29udGVudDogZmxleC1zdGFydDtcXG4gICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICAgIHBhZGRpbmc6IDM1cHg7XFxuICAgICAgYm9yZGVyLXJhZGl1czogOHB4O1xcbiAgICAgIGJhY2tncm91bmQ6ICNmZmY7XFxuXFxuICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gICAgfVxcblxcbiAgICAuY2xvc2UtbW9kYWwgKiB7XFxuICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gICAgfVxcblxcbiAgICAuY2xvc2UtbW9kYWxfX3RleHQge1xcbiAgICAgIG1hcmdpbjogNDBweCBhdXRvIDMwcHg7XFxuICAgICAgZm9udC13ZWlnaHQ6IDYwMDtcXG4gICAgICBmb250LXNpemU6IDI0cHg7XFxuICAgICAgbGluZS1oZWlnaHQ6IDM2cHg7XFxuICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xcblxcbiAgICAgIGNvbG9yOiAjMjQyNTM5O1xcbiAgICB9XFxuXFxuICAgIC5jbG9zZS1tb2RhbF9fYnV0dG9uLWNvbnRhaW5lciB7XFxuICAgICAgd2lkdGg6IDMxOHB4O1xcbiAgICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgICAgZmxleC1mbG93OiByb3cgbm93cmFwO1xcbiAgICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcXG4gICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICB9XFxuXFxuICAgIC5jbG9zZS1tb2RhbF9fYnV0dG9uIHtcXG4gICAgICBiYWNrZ3JvdW5kOiAjZmZmO1xcbiAgICAgIGJvcmRlcjogMnB4IHNvbGlkICNFREVFRjM7XFxuICAgICAgYm9yZGVyLXJhZGl1czogNzRweDtcXG4gICAgICB3aWR0aDogMTUycHg7XFxuICAgICAgaGVpZ2h0OiA1NnB4O1xcbiAgICAgIGN1cnNvcjogcG9pbnRlcjtcXG4gICAgICBmb250LXdlaWdodDogNjAwO1xcbiAgICAgIGZvbnQtc2l6ZTogMTRweDtcXG4gICAgICBsaW5lLWhlaWdodDogMjFweDtcXG4gICAgICBjb2xvcjogIzJCMkQ1NjtcXG4gICAgICB0ZXh0LXRyYW5zZm9ybTogdXBwZXJjYXNlO1xcbiAgICB9XFxuXFxuICAgIC5jbG9zZS1tb2RhbF9fYnV0dG9uLS1leGl0IHtcXG4gICAgICBiYWNrZ3JvdW5kOiAjREQzRTU2O1xcbiAgICAgIGJveC1zaGFkb3c6IDBweCA4cHggMzRweCByZ2JhKDIyMSwgNjIsIDg2LCAwLjQpO1xcbiAgICAgIGNvbG9yOiAjZmZmO1xcbiAgICAgIGJvcmRlci1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICAgIH1cXG4gIFwiKTtcclxuICAgIHJldHVybiBzdHlsZXM7XHJcbn1cblxudmFyIFJhbXBJbnN0YW50U0RLID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUmFtcEluc3RhbnRTREsoY29uZmlnKSB7XHJcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0gaW5pdEV2ZW50TGlzdGVuZXJzRGljdCgpO1xyXG4gICAgICAgIHRoaXMuX2lzVmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX29uU2VuZENyeXB0b0NhbGxiYWNrID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIGltcG9ydEZvbnRzKCk7XHJcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZSA9IHRoaXMudW5zdWJzY3JpYmUuYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLm9uID0gdGhpcy5vbi5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuc2hvdyA9IHRoaXMuc2hvdy5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuX2hhbmRsZUVzY2FwZUNsaWNrID0gdGhpcy5faGFuZGxlRXNjYXBlQ2xpY2suYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLl9kaXNwYXRjaEV2ZW50ID0gdGhpcy5fZGlzcGF0Y2hFdmVudC5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuX3N1YnNjcmliZVRvV2lkZ2V0RXZlbnRzID0gdGhpcy5fc3Vic2NyaWJlVG9XaWRnZXRFdmVudHMuYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLl9vbiA9IHRoaXMuX29uLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJTZGtFdmVudEhhbmRsZXJzID0gdGhpcy5fcmVnaXN0ZXJTZGtFdmVudEhhbmRsZXJzLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5fc3Vic2NyaWJlVG9XaWRnZXRFdmVudHMgPSB0aGlzLl9zdWJzY3JpYmVUb1dpZGdldEV2ZW50cy5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuX29uU2VuZENyeXB0byA9IHRoaXMuX29uU2VuZENyeXB0by5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuX3Jhd05vcm1hbGl6ZWRDb25maWcgPSBub3JtYWxpemVDb25maWdBbmRMb2dFcnJvcnNPbkludmFsaWRGaWVsZHMoX19hc3NpZ24oeyB2YXJpYW50OiAnZGVza3RvcCcgfSwgY29uZmlnKSk7XHJcbiAgICAgICAgdGhpcy5fY29uZmlnID0gX19hc3NpZ24oX19hc3NpZ24oe30sIHRoaXMuX3Jhd05vcm1hbGl6ZWRDb25maWcpLCB0aGlzLl9nZXRIb3N0Q29uZmlnU2RrUGFyYW1zKHRoaXMuX3Jhd05vcm1hbGl6ZWRDb25maWcsIGNvbmZpZy51c2VTZW5kQ3J5cHRvQ2FsbGJhY2spKTtcclxuICAgIH1cclxuICAgIFJhbXBJbnN0YW50U0RLLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9pc1Zpc2libGUpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXaWRnZXQgaXMgYWxyZWFkeSB2aXNpYmxlIC0geW91IGNhbiBvbmx5IGNhbGwgdGhpcyBvbmNlIHBlciBpbnN0YW5jZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiBpc0h0bWxFbGVtZW50KGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKSB7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuYmx1cigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9yZWdpc3RlclNka0V2ZW50SGFuZGxlcnMoKTtcclxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHRoaXMuX3N1YnNjcmliZVRvV2lkZ2V0RXZlbnRzKTtcclxuICAgICAgICBpZiAodGhpcy5faXNDb25maWd1cmVkQXNIb3N0ZWQoKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9zaG93VXNpbmdIb3N0ZWRNb2RlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX2lzQ29uZmlndXJlZEFzRW1iZWRkZWQoKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9zaG93VXNpbmdFbWJlZGRlZE1vZGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5faXNDb25maWd1cmVkV2l0aE92ZXJsYXkoKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9zaG93VXNpbmdPdmVybGF5TW9kZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX2hhbmRsZUVzY2FwZUNsaWNrLCB0cnVlKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICBSYW1wSW5zdGFudFNESy5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAodHlwZSwgY2FsbGJhY2spIHtcclxuICAgICAgICB0aGlzLl9vbih0eXBlLCBjYWxsYmFjaywgZmFsc2UpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIFJhbXBJbnN0YW50U0RLLnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uICh0eXBlLCBjYWxsYmFjaykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKHR5cGUgPT09ICcqJykge1xyXG4gICAgICAgICAgICB2YXIgYWxsVHlwZXMgPSBPYmplY3QuZW50cmllcyh0aGlzLl9saXN0ZW5lcnMpO1xyXG4gICAgICAgICAgICBhbGxUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IF9hWzBdLCBldmVudEhhbmRsZXJzID0gX2FbMV07XHJcbiAgICAgICAgICAgICAgICB2YXIgZmlsdGVyZWRIYW5kbGVycyA9IGV2ZW50SGFuZGxlcnMuZmlsdGVyKGZ1bmN0aW9uIChsKSB7IHJldHVybiBsLmNhbGxiYWNrICE9PSBjYWxsYmFjazsgfSk7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fbGlzdGVuZXJzW2tleV0gPSBmaWx0ZXJlZEhhbmRsZXJzO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xpc3RlbmVyc1t0eXBlXSA9IHRoaXMuX2xpc3RlbmVyc1t0eXBlXS5maWx0ZXIoZnVuY3Rpb24gKGwpIHsgcmV0dXJuIGwuY2FsbGJhY2sgIT09IGNhbGxiYWNrOyB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgUmFtcEluc3RhbnRTREsucHJvdG90eXBlLl9vbiA9IGZ1bmN0aW9uICh0eXBlLCBjYWxsYmFjaywgaW50ZXJuYWwpIHtcclxuICAgICAgICBpZiAodHlwZSAhPT0gJyonICYmICF0aGlzLl9saXN0ZW5lcnNbdHlwZV0pIHtcclxuICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWNvbnNvbGVcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVW5rbm93biAvIHVuc3VwcG9ydGVkIGV2ZW50IG5hbWUgLSAnXCIuY29uY2F0KHR5cGUsIFwiJy4gVGhpcyBsaXN0ZW5lciB3aWxsIGhhdmUgbm8gZWZmZWN0LlwiKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlID09PSAnKicpIHtcclxuICAgICAgICAgICAgdmFyIGFsbFR5cGVzID0gT2JqZWN0LnZhbHVlcyh0aGlzLl9saXN0ZW5lcnMpO1xyXG4gICAgICAgICAgICBhbGxUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudEhhbmRsZXJzKSB7IHJldHVybiBldmVudEhhbmRsZXJzLnB1c2goeyBjYWxsYmFjazogY2FsbGJhY2ssIGludGVybmFsOiBpbnRlcm5hbCB9KTsgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9saXN0ZW5lcnNbdHlwZV0ucHVzaCh7IGNhbGxiYWNrOiBjYWxsYmFjaywgaW50ZXJuYWw6IGludGVybmFsIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBSYW1wSW5zdGFudFNESy5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5fZGlzcGF0Y2hFdmVudCh7XHJcbiAgICAgICAgICAgIHR5cGU6IFdpZGdldEV2ZW50VHlwZXMuV0lER0VUX0NMT1NFLFxyXG4gICAgICAgICAgICBwYXlsb2FkOiBudWxsLFxyXG4gICAgICAgICAgICB3aWRnZXRJbnN0YW5jZUlkOiB0aGlzLl9jb25maWcud2lkZ2V0SW5zdGFuY2VJZCxcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICBSYW1wSW5zdGFudFNESy5wcm90b3R5cGUub25TZW5kQ3J5cHRvID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdGhpcy5fb25TZW5kQ3J5cHRvQ2FsbGJhY2sgPSBjYWxsYmFjaztcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICBSYW1wSW5zdGFudFNESy5wcm90b3R5cGUub25SZXF1ZXN0Q3J5cHRvQWNjb3VudCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIG9uUmVxdWVzdENyeXB0b0FjY291bnQgPSBmdW5jdGlvbiAoZXZlbnQpIHsgcmV0dXJuIF9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCwgZV8xLCBlcnJvck1lc3NhZ2U7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnRyeXMucHVzaChbMCwgMiwgLCAzXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGNhbGxiYWNrKGV2ZW50LnBheWxvYWQudHlwZSwgZXZlbnQucGF5bG9hZC5hc3NldFN5bWJvbCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdC5hZGRyZXNzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgYWRkcmVzcyBpbiB0aGUgY2FsbGJhY2sgcmVzdWx0Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgM107XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlXzEgPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9IHZvaWQgMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlXzEgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBlXzE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZV8xIGluc3RhbmNlb2YgRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9IGVfMS5tZXNzYWdlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NlbmRFdmVudFRvV2lkZ2V0KHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IEludGVybmFsU2RrRXZlbnRUeXBlcy5SRVFVRVNUX0NSWVBUT19BQ0NPVU5UX1JFU1VMVCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQ6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3JNZXNzYWdlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NlbmRFdmVudFRvV2lkZ2V0KHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IEludGVybmFsU2RrRXZlbnRUeXBlcy5SRVFVRVNUX0NSWVBUT19BQ0NPVU5UX1JFU1VMVCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQ6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiByZXN1bHQuYWRkcmVzcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiByZXN1bHQudHlwZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiByZXN1bHQubmFtZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NldFN5bWJvbDogcmVzdWx0LmFzc2V0U3ltYm9sLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7IH07XHJcbiAgICAgICAgdGhpcy5fb24oSW50ZXJuYWxFdmVudFR5cGVzLlJFUVVFU1RfQ1JZUFRPX0FDQ09VTlQsIG9uUmVxdWVzdENyeXB0b0FjY291bnQsIHRydWUpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIFJhbXBJbnN0YW50U0RLLnByb3RvdHlwZS5fc3Vic2NyaWJlVG9XaWRnZXRFdmVudHMgPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICBpZiAoIWV2ZW50LmRhdGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWFyZVVybHNFcXVhbChldmVudC5vcmlnaW4sIGdldEJhc2VVcmwodGhpcy5fY29uZmlnKS5vcmlnaW4pKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGV2ZW50RGF0YSA9IGV2ZW50LmRhdGE7XHJcbiAgICAgICAgaWYgKCFldmVudERhdGEud2lkZ2V0SW5zdGFuY2VJZCB8fFxyXG4gICAgICAgICAgICBldmVudERhdGEud2lkZ2V0SW5zdGFuY2VJZCAhPT0gdGhpcy5fY29uZmlnLndpZGdldEluc3RhbmNlSWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9kaXNwYXRjaEV2ZW50KGV2ZW50RGF0YSk7XHJcbiAgICB9O1xyXG4gICAgUmFtcEluc3RhbnRTREsucHJvdG90eXBlLl9yZWdpc3RlclNka0V2ZW50SGFuZGxlcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLl9vbihXaWRnZXRFdmVudFR5cGVzLldJREdFVF9DTE9TRSwgZnVuY3Rpb24gKF9ldmVudCkge1xyXG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgICAgICBpZiAoX3RoaXMuX2lzQ29uZmlndXJlZEFzSG9zdGVkKCkpIHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgKF9hID0gX3RoaXMud2lkZ2V0V2luZG93KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2xvc2UoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgY2xvc2UgdGhlIHdpZGdldCB3aW5kb3cnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIChfYiA9IF90aGlzLmRvbU5vZGVzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc2hhZG93SG9zdC5yZW1vdmUoKTtcclxuICAgICAgICAgICAgICAgIGNsZWFyQWxsQm9keVNjcm9sbExvY2tzKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgX3RoaXMuX3RlYXJkb3duRXZlbnRTdWJzY3JpcHRpb25zKCk7XHJcbiAgICAgICAgfSwgdHJ1ZSk7XHJcbiAgICAgICAgdmFyIG9uQ29uZmlnRXZlbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgICAgIGlmIChfdGhpcy5faXNDb25maWd1cmVkQXNIb3N0ZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIChfYSA9IF90aGlzLmRvbU5vZGVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaWZyYW1lLmNsYXNzTGlzdC5hZGQoJ3Zpc2libGUnKTtcclxuICAgICAgICAgICAgdmFyIGxvYWRlciA9IChfYiA9IF90aGlzLmRvbU5vZGVzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc2hhZG93LnF1ZXJ5U2VsZWN0b3IoJy5sb2FkZXItY29udGFpbmVyJyk7XHJcbiAgICAgICAgICAgIGlmIChsb2FkZXIpIHtcclxuICAgICAgICAgICAgICAgIGxvYWRlci5yZW1vdmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKHRoaXMuX2NvbmZpZy51c2VTZW5kQ3J5cHRvQ2FsbGJhY2tWZXJzaW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMub24oSW50ZXJuYWxFdmVudFR5cGVzLlNFTkRfQ1JZUFRPLCB0aGlzLl9vblNlbmRDcnlwdG8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9vbihXaWRnZXRFdmVudFR5cGVzLldJREdFVF9DT05GSUdfRE9ORSwgb25Db25maWdFdmVudCwgdHJ1ZSk7XHJcbiAgICAgICAgdGhpcy5fb24oV2lkZ2V0RXZlbnRUeXBlcy5XSURHRVRfQ09ORklHX0ZBSUxFRCwgb25Db25maWdFdmVudCwgdHJ1ZSk7XHJcbiAgICAgICAgdGhpcy5fb24oSW50ZXJuYWxFdmVudFR5cGVzLldJREdFVF9DTE9TRV9SRVFVRVNULCBmdW5jdGlvbiAoX2V2ZW50KSB7XHJcbiAgICAgICAgICAgIGlmIChfdGhpcy5faXNDb25maWd1cmVkQXNIb3N0ZWQoKSB8fCBfdGhpcy5faXNDb25maWd1cmVkQXNFbWJlZGRlZCgpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKF90aGlzLl9jb25maWcudmFyaWFudCA9PT0gJ21vYmlsZScgfHwgaXNDbG9zZU1vZGFsQWxyZWFkeU9wZW4oX3RoaXMuZG9tTm9kZXMub3ZlcmxheSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBfdGhpcy5kb21Ob2Rlcy5vdmVybGF5LmFwcGVuZENoaWxkKHByZXBhcmVDbG9zZU1vZGFsTm9kZShfdGhpcy5fZGlzcGF0Y2hFdmVudCkpO1xyXG4gICAgICAgIH0sIHRydWUpO1xyXG4gICAgICAgIHRoaXMuX29uKEludGVybmFsRXZlbnRUeXBlcy5XSURHRVRfQ0xPU0VfUkVRVUVTVF9DT05GSVJNRUQsIGZ1bmN0aW9uIChfZXZlbnQpIHtcclxuICAgICAgICAgICAgX3RoaXMuX2Rpc3BhdGNoRXZlbnQoe1xyXG4gICAgICAgICAgICAgICAgdHlwZTogV2lkZ2V0RXZlbnRUeXBlcy5XSURHRVRfQ0xPU0UsXHJcbiAgICAgICAgICAgICAgICBwYXlsb2FkOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgd2lkZ2V0SW5zdGFuY2VJZDogX3RoaXMuX2NvbmZpZy53aWRnZXRJbnN0YW5jZUlkLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LCB0cnVlKTtcclxuICAgICAgICB0aGlzLl9vbihJbnRlcm5hbEV2ZW50VHlwZXMuV0lER0VUX0NMT1NFX1JFUVVFU1RfQ0FOQ0VMTEVELCBmdW5jdGlvbiAoX2V2ZW50KSB7XHJcbiAgICAgICAgICAgIGlmIChfdGhpcy5faXNDb25maWd1cmVkQXNIb3N0ZWQoKSB8fCBfdGhpcy5faXNDb25maWd1cmVkQXNFbWJlZGRlZCgpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIG1vZGFsID0gX3RoaXMuZG9tTm9kZXMub3ZlcmxheS5xdWVyeVNlbGVjdG9yKCcuY2xvc2UtbW9kYWwnKTtcclxuICAgICAgICAgICAgaWYgKG1vZGFsKSB7XHJcbiAgICAgICAgICAgICAgICBtb2RhbC5yZW1vdmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIHRydWUpO1xyXG4gICAgfTtcclxuICAgIFJhbXBJbnN0YW50U0RLLnByb3RvdHlwZS5fc2VuZEV2ZW50VG9XaWRnZXQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICB2YXIgX2EsIF9iLCBfYztcclxuICAgICAgICBpZiAoIXRoaXMuX2lzVmlzaWJsZSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXaWRnZXQgaXMgbm90IHZpc2libGUgY291bGRuJ3Qgc2VuZCB0aGUgZXZlbnRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIChfYyA9ICgoX2EgPSB0aGlzLndpZGdldFdpbmRvdykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKF9iID0gdGhpcy5kb21Ob2RlcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmlmcmFtZS5jb250ZW50V2luZG93KSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnBvc3RNZXNzYWdlKGV2ZW50LCBnZXRCYXNlVXJsKHRoaXMuX2NvbmZpZykub3JpZ2luKTtcclxuICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWVtcHR5XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChfZCkgeyB9XHJcbiAgICB9O1xyXG4gICAgUmFtcEluc3RhbnRTREsucHJvdG90eXBlLl9kaXNwYXRjaEV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgdmFyIHR5cGUgPSBldmVudC50eXBlO1xyXG4gICAgICAgIHRoaXMuX2xpc3RlbmVyc1t0eXBlXS5mb3JFYWNoKGZ1bmN0aW9uIChoYW5kbGVyKSB7IHJldHVybiBoYW5kbGVyLmNhbGxiYWNrKGV2ZW50KTsgfSk7XHJcbiAgICB9O1xyXG4gICAgUmFtcEluc3RhbnRTREsucHJvdG90eXBlLl9oYW5kbGVFc2NhcGVDbGljayA9IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgIHZhciBlc2NLZXlDb2RlID0gMjc7XHJcbiAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gJ0VzY2FwZScgfHwgZXZlbnQua2V5ID09PSAnRXNjJyB8fCBldmVudC5rZXlDb2RlID09PSBlc2NLZXlDb2RlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2Rpc3BhdGNoRXZlbnQoe1xyXG4gICAgICAgICAgICAgICAgdHlwZTogSW50ZXJuYWxFdmVudFR5cGVzLldJREdFVF9DTE9TRV9SRVFVRVNULFxyXG4gICAgICAgICAgICAgICAgcGF5bG9hZDogbnVsbCxcclxuICAgICAgICAgICAgICAgIGludGVybmFsOiB0cnVlLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgUmFtcEluc3RhbnRTREsucHJvdG90eXBlLl9vblNlbmRDcnlwdG8gPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0LCBlXzIsIGVycm9yTWVzc2FnZTtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50LmV2ZW50VmVyc2lvbiAhPT0gU0VORF9DUllQVE9fU1VQUE9SVEVEX1ZFUlNJT04pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1jb25zb2xlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJ1bnN1cHBvcnRlZCBldmVudCB2ZXJzaW9uIC0gJ1wiLmNvbmNhdChldmVudCwgXCInLiBUaGlzIGxpc3RlbmVyIHdpbGwgaGF2ZSBubyBlZmZlY3QuXCIpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfYi50cnlzLnB1c2goWzEsIDMsICwgNF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCAoKF9hID0gdGhpcy5fb25TZW5kQ3J5cHRvQ2FsbGJhY2spID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMsIGV2ZW50LnBheWxvYWQuYXNzZXRJbmZvLCBldmVudC5wYXlsb2FkLmFtb3VudCwgZXZlbnQucGF5bG9hZC5hZGRyZXNzKSldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gX2Iuc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShyZXN1bHQgPT09IG51bGwgfHwgcmVzdWx0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXN1bHQudHhIYXNoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHR4SGFzaCBpbiB0aGUgY2FsbGJhY2sgcmVzdWx0Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlXzIgPSBfYi5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9IHZvaWQgMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlXzIgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBlXzI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZV8yIGluc3RhbmNlb2YgRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9IGVfMi5tZXNzYWdlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NlbmRFdmVudFRvV2lkZ2V0KHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50VmVyc2lvbjogU0VORF9DUllQVE9fU1VQUE9SVEVEX1ZFUlNJT04sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBJbnRlcm5hbFNka0V2ZW50VHlwZXMuU0VORF9DUllQVE9fUkVTVUxULFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvck1lc3NhZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2VuZEV2ZW50VG9XaWRnZXQoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRWZXJzaW9uOiBTRU5EX0NSWVBUT19TVVBQT1JURURfVkVSU0lPTixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IEludGVybmFsU2RrRXZlbnRUeXBlcy5TRU5EX0NSWVBUT19SRVNVTFQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHhIYXNoOiByZXN1bHQudHhIYXNoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLy8gRXZlbnQgc3Vic2NyaXB0aW9ucyBhcmVuJ3QgY2xlYXJlZCBzbyB0aGF0IGhvc3QgY2FuIHJlY2VpdmUgYSBQQVlNRU5UX1NVQ0NFU1NGVUwgZXZlbnRcclxuICAgIC8vIGV2ZW4gYWZ0ZXIgdGhlIHdpZGdldCBoYXMgYmVlbiBjbG9zZWRcclxuICAgIFJhbXBJbnN0YW50U0RLLnByb3RvdHlwZS5fdGVhcmRvd25FdmVudFN1YnNjcmlwdGlvbnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9oYW5kbGVFc2NhcGVDbGljaywgdHJ1ZSk7XHJcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB0aGlzLl9zdWJzY3JpYmVUb1dpZGdldEV2ZW50cyk7XHJcbiAgICB9O1xyXG4gICAgUmFtcEluc3RhbnRTREsucHJvdG90eXBlLl9zaG93VXNpbmdFbWJlZGRlZE1vZGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICB2YXIgd2lkZ2V0VXJsID0gaW5pdFdpZGdldElmcmFtZVVybCh0aGlzLl9jb25maWcpO1xyXG4gICAgICAgIHRoaXMuZG9tTm9kZXMgPSBpbml0RE9NTm9kZVdpdGhvdXRPdmVybGF5KHdpZGdldFVybCwgdGhpcy5fZGlzcGF0Y2hFdmVudCwgdGhpcy5fY29uZmlnKTtcclxuICAgICAgICBpZiAoISgoX2EgPSB0aGlzLmRvbU5vZGVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYm9keSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCA8Ym9keT4gZWxlbWVudC5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIChfYiA9IHRoaXMuX2NvbmZpZy5jb250YWluZXJOb2RlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYXBwZW5kQ2hpbGQodGhpcy5kb21Ob2Rlcy5zaGFkb3dIb3N0KTtcclxuICAgICAgICB0aGlzLl9pc1Zpc2libGUgPSB0cnVlO1xyXG4gICAgfTtcclxuICAgIFJhbXBJbnN0YW50U0RLLnByb3RvdHlwZS5fc2hvd1VzaW5nT3ZlcmxheU1vZGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHZhciB3aWRnZXRVcmwgPSBpbml0V2lkZ2V0SWZyYW1lVXJsKHRoaXMuX2NvbmZpZyk7XHJcbiAgICAgICAgdGhpcy5kb21Ob2RlcyA9IGluaXRET01Ob2RlV2l0aE92ZXJsYXkod2lkZ2V0VXJsLCB0aGlzLl9kaXNwYXRjaEV2ZW50LCB0aGlzLl9jb25maWcpO1xyXG4gICAgICAgIGlmICghKChfYSA9IHRoaXMuZG9tTm9kZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ib2R5KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIDxib2R5PiBlbGVtZW50LlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5kb21Ob2Rlcy5ib2R5LmFwcGVuZENoaWxkKHRoaXMuZG9tTm9kZXMuc2hhZG93SG9zdCk7XHJcbiAgICAgICAgdGhpcy5faXNWaXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICBkaXNhYmxlQm9keVNjcm9sbCh0aGlzLmRvbU5vZGVzLmlmcmFtZSk7XHJcbiAgICAgICAgdmFyIHdpZGdldE1vZGUgPSBkZXRlcm1pbmVXaWRnZXRWYXJpYW50KHRoaXMuX2NvbmZpZyk7XHJcbiAgICAgICAgaWYgKHdpZGdldE1vZGUgIT09ICdkZXNrdG9wJyAmJiB3aWRnZXRNb2RlICE9PSAnZW1iZWRkZWQtZGVza3RvcCcpIHtcclxuICAgICAgICAgICAgaGlkZVdlYnNpdGVCZWxvdyh0aGlzLmRvbU5vZGVzLnNoYWRvdyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFJhbXBJbnN0YW50U0RLLnByb3RvdHlwZS5fc2hvd1VzaW5nSG9zdGVkTW9kZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgdmFyIHdpZGdldFVybCA9IGluaXRXaWRnZXRJZnJhbWVVcmwodGhpcy5fY29uZmlnKTtcclxuICAgICAgICB0aGlzLndpZGdldFdpbmRvdyA9IChfYSA9IHdpbmRvdy5vcGVuKHdpZGdldFVybCkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHVuZGVmaW5lZDtcclxuICAgIH07XHJcbiAgICBSYW1wSW5zdGFudFNESy5wcm90b3R5cGUuX2lzQ29uZmlndXJlZFdpdGhPdmVybGF5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBbJ2Rlc2t0b3AnLCAnbW9iaWxlJ10uaW5jbHVkZXModGhpcy5fY29uZmlnLnZhcmlhbnQpO1xyXG4gICAgfTtcclxuICAgIFJhbXBJbnN0YW50U0RLLnByb3RvdHlwZS5faXNDb25maWd1cmVkQXNIb3N0ZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIFsnaG9zdGVkLWRlc2t0b3AnLCAnaG9zdGVkLW1vYmlsZSddLmluY2x1ZGVzKHRoaXMuX2NvbmZpZy52YXJpYW50KTtcclxuICAgIH07XHJcbiAgICBSYW1wSW5zdGFudFNESy5wcm90b3R5cGUuX2lzQ29uZmlndXJlZEFzRW1iZWRkZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIFsnZW1iZWRkZWQtZGVza3RvcCcsICdlbWJlZGRlZC1tb2JpbGUnXS5pbmNsdWRlcyh0aGlzLl9yYXdOb3JtYWxpemVkQ29uZmlnLnZhcmlhbnQpO1xyXG4gICAgfTtcclxuICAgIFJhbXBJbnN0YW50U0RLLnByb3RvdHlwZS5fZ2V0SG9zdENvbmZpZ1Nka1BhcmFtcyA9IGZ1bmN0aW9uIChjb25maWcsIHVzZVNlbmRDcnlwdG9DYWxsYmFjaykge1xyXG4gICAgICAgIHZhciB3aWRnZXRWYXJpYW50ID0gZGV0ZXJtaW5lV2lkZ2V0VmFyaWFudChjb25maWcpO1xyXG4gICAgICAgIHJldHVybiBfX2Fzc2lnbih7IHNka1R5cGU6ICdXRUInLCBzZGtWZXJzaW9uOiBTREtfVkVSU0lPTiwgdmFyaWFudDogd2lkZ2V0VmFyaWFudCwgd2lkZ2V0SW5zdGFuY2VJZDogZ2V0UmFuZG9tSW50U3RyaW5nKCkgfSwgKHVzZVNlbmRDcnlwdG9DYWxsYmFja1xyXG4gICAgICAgICAgICA/IHsgdXNlU2VuZENyeXB0b0NhbGxiYWNrVmVyc2lvbjogU0VORF9DUllQVE9fU1VQUE9SVEVEX1ZFUlNJT04gfVxyXG4gICAgICAgICAgICA6IHt9KSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFJhbXBJbnN0YW50U0RLO1xyXG59KCkpO1xuXG5leHBvcnQgeyBXaWRnZXRFdmVudFR5cGVzIGFzIFJhbXBJbnN0YW50RXZlbnRUeXBlcywgUmFtcEluc3RhbnRTREsgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJhbXAtaW5zdGFudC1zZGsuZXM1LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ramp-network/ramp-instant-sdk/dist/ramp-instant-sdk.es5.js\n");

/***/ })

};
;